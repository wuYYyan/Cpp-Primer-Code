#include <stdio.h>

int main()
{
    float sum = 0;
    for (int i  = 0; i < 100; i ++)
        sum += 0.1;
    printf("%f\n", sum); // 10.000002，因为浮点数的精度问题，所以不是10

    return 0;
}

/* 一、小数在计算机中是如何用二进制表示的
    1.小数点之前的二进制数，从小数点开始，向左边的数，每一位都是2的n次方，n从0开始，向左边递增
    2.小数点之后的二进制数，从小数点开始，向右边的数，每一位都是2的-n次方，n从1开始，向右边递增
    3.需要注意的是整数与小数部分n的起始数值不一样，整数部分n从0开始，小数部分n从1开始
    4.例如：二进制表示1011.0011，整数部分为1101，小数部分为0011
        转换为十进制的整数部分为：1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11
        转换为十进制的小数部分为：0*2^-1 + 0*2^-2 + 1*2^-3 + 1*2^-4 = 0.1875
        因此最终转化的十进制数是：13.1875
*/ 

/* 二、计算机进行浮点运算出错的原因
    假设在二进制的表示法下精度有四位，则可以枚举所有可能如下：
    0.0000 0.0001 0.0010 0.0011 0.0100 0.0101 0.0110 0.0111
    0.1000 0.1001 0.1010 0.1011 0.1100 0.1101 0.1110 0.1111
    如果将以上所有二进制表示转化为十进制，就会发现表示出的十进制数彼此之间不是连续的
    同理，只要二进制的精度是有限制的，那么它所能表示的十进制数彼此之间就一定是有空隙的
    如果将十进制的0.1转化为二进制，就会发现它是一个无限循环小数，因此最终在有限精度的表示下就会出现误差
*/

/* 三、浮点数在内存中是如何存储的
    单精度浮点数在内存中占四个字节，共32位，双精度浮点数在内存中占八个字节，共64位
    按照IEEE754标准，浮点数在内存中的二进制表示规则如下：
        将任意浮点数表示为：± * M * 2^E，其中E为指数位，M为尾数位
        规定尾数位是一个整数部分为1的小数，指数位则表示小数点在尾数位中的偏移量
    上述32位或64位的二进制数，可以分为三个部分：符号位 + 指数位 + 尾数位
    1.符号位：用来表示正负，0表示正数，1表示负数，单精度、双精度浮点数中均是1位
    2.指数位：用来表示小数点的位置，单精度浮点数中是8位，双精度浮点数中是11位(需要同时考虑正次幂和负次幂)
    3.尾数位：用来表示小数点后面的数(因为上面已经规定了整数部分一定是1)，单精度浮点数中是23位，双精度浮点数中是52位
            当位数不够时，在后面补零
*/

/* 四、负数在计算机中是如何存储的
    负数：原码；反码：符号位不变，其他位按位取反；补码：反码+1
    负数在计算机中以补码的形式存储
*/