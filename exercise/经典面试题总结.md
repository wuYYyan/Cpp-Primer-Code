# C++

## 基础部分

### :rocket: **C和C++有什么异同？**

- C++(C with classes)引入了类、引用的概念，而C中均没有
- C++引入 new/delete 运算符，取代了C中的 malloc/free 库函数
- C++中允许在程序的任意位置声明变量，而C只允许在程序的开头声明变量
- C++扩展了运算符重载的概念，允许为用户定义的类型重新定义运算符的含义
- C是面向过程编程的语言，而**C++是集基于对象编程(单一类或多个类彼此之间无关联)、面向对象编程(设计的类彼此之间有关联)、泛型编程、函数式编程和面向过程编程的语言**
- C++中自定义函数时形参列表为空与在括号中使用 void 等效，都表示不接收参数；而在C中括号为空意味着对是否接受参数保持沉默，即可以接收、也可以不接收
- C++对于变量名称的长度无限制，名称中所有的字符都有意义；而ANSI C(C99标准)只保证变量名称中前63个字符有意义，即前63个字符相同的名称被认为是相同的
- C++中认为`int a = 1; int a(1); int a = {1}; int a {1};`四种形式对变量的声明都是合法的，而C只认为`int a = 1;`赋值方式是合法的(其他数组等容器的初始化方式相同)
- C语言允许将 void * 的指针隐式转换为任意类型的指针，C++不允许
**综上所述，C++是C的超集，C是C++的子集。**

### :rocket: **getline() 和 get() 有什么异同？**

- 两者都**可以**是 istream 类中的成员函数/类方法，即都是面向行的读取输入函数，都可以通过句点表示法调用，如`cin.getline(*, *);`、`cin.get(*, *);`(但 getline() 也有不是类方法的调用情况，见函数重载)
-  cin.getline(Name, Size) 与 cin.get(Name, Size) 功能相同：第一个参数 Name 是用来存储输入行的数组的名称，第二个参数 Size 是要读取的字符数；两种用法都返回一个 cin 对象，因此有正确用法：`cin.get(Name, Size).get();`与`cin.getline(Name1, Size1).getline(Name2, Size2);` 
- **使用时两者都通过回车键输入的换行符来确定输入结尾**，但 getline() 将丢弃换行符，存储字符串时用空字符来代替换行符；而 get() 并不丢弃，且将其保留在输入队列中，因此需要用如下代码片段来跨过换行符，连续进行多个输入时要特别注意

```C++
while(cin.get() != "\n")
    continue;
```   

- 两者都有函数重载，具体见C++ Primer Plus Chapter 8：因此 get() 存在有不带任何参数的 cin.get() ，该函数可读取单个字符(即便是换行符)，这种用法常在`cin.get(Name, Size);`后面使用，即`cin.get(Name, Size).get();` 
-  getline() 用于读取面向整行的输入，用法`getline(cin, str);` 将 cin 作为参数，指出到哪里去查找输入，另外也没有指出字符串长度的参数，因为 string对象 将根据字符串的长度自动调整自己的大小，即此时的 getline() 是 <string> 的库函数
参考链接：[C++字符&字符串(字符数组)的输入输出](https://blog.csdn.net/Buster001/article/details/100083803)

### :rocket: **string对象 和 字符数组 有什么异同？**

- 使用 string 对象的方式与使用字符数组相同：可以使用C风格字符串(字符串字面值)来初始化 string 对象，可以使用 cin 将键盘输入存储到 string 对象中，可以使用 cout 显示 string 对象，可以使用数组表示法/下标索引来访问存储在 string 对象中的字符
- 可以将 string 对象声明为简单变量，而不是数组；要使用 string 类，必须在程序中包含头文件 <string> ，并且编译命名空间 using namespace std;  
-  string 对象可以互相整体赋值，而字符数组不可以，因为数组名的本质是个常量指针
- 类设计能够让程序自动处理 string 对象的大小，这使得与字符数组相比 string 对象更方便更安全
-  string 类中有类方法 size() ，可以获取 string 对象中包含的字符数，而字符数组只能使用 strlen 函数
- 未被初始化的 string 对象的长度被自动设置为0；而未被初始化的字符数组中第一个空字符的出现位置是随机的，这就给函数 strlen() 的运行结果带来了不确定性
- C++提供了三种表示C-风格字符串的方法：字符数组、字符串字面值和字符串指针，它们的类型都是 char * 

```C++
#include <string>
#include <iostream>

using namespace std;

int main()
{
    string str1;
    string str2 = "panther";

    cout << "Enter a kind of feline: "; //输入fox
    cin >> str1;

    cout << str1 << endl; //输出fox，类似于普通变量的输出方式
    cout << str2[0] << endl; //输出p，采用数组下标索引的方式进行访问

    return 0;
}
```

> :rocket: **sizeof 和 strlen 有什么异同？**

-  sizeof 是一个运算符(类似于加减乘除)，而 strlen 是 cstring 头文件中的库函数
-  sizeof 的参数可以是数据的类型，也可以是变量；而 strlen 只能是以结尾为 ‘\0’ 的字符串(**字符串变量、字符数组**)作参数
- 编译器在编译时就计算出了 sizeof 的结果，而 strlen 函数必须在运行时才能计算出来
-  sizeof 返回的是数据类型占内存的大小；而 strlen 返回的是存储在数组中的字符串的长度，而不是数组本身的长度，另外只包含可见字符，即不包含空字符。因此如果存储 cosmic 字符串，数组的长度不能短于 strlen(cosmic) + 1 
- 数组做 sizeof 的参数不退化，而传递给 strlen 时就退化为指针了

```C++
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 4;
    //操作符sizeof()的参数可以是变量的类型，也可以是变量名
    cout << sizeof(int) << ' ' << sizeof(a) << endl; //输出均为4

    char p[10] = "wuyan";
    cout << sizeof(p) << ' ' << strlen(p) << endl; //前者输出10，后者输出5
    //说明操作符sizeof()返回的是变量所占内存的大小，而函数strlen()返回的是字符串的长度，还不包含空字符
    //在这种情况下，不会将数组名解释为第一个元素的地址，这是数组名与指向数组的指针的区别所在
    return 0;
}
//20230319_sizeof与strlen的区别.cpp
```

### :rocket: **数组名与指向数组的指针有什么异同？**

- 刚开始时它们都指向数组的第一个元素，因此 n[i] 、 pn[i] 、 *(n + i) 与 *(pn + i) 等效，均表示数组的第 i 个元素; &n[i] 、 &pn[i] 、 (n + i) 与 (pn + i) 等效，均表示数组的第 i 个元素的地址( pn 是指向数组 n 的指针)
- 注意 n 与 &n 之间的区别：前者指向数组中的第一个元素，而后者指向整个数组，因此 n + 1 指向数组中的下一个元素，而 &n + 1 指向后面一个12字节内存块(这里认为数组含有三个 int 类型元素，且 int 类型占四个字节)；另一个区别是为了得到数组中的第一个元素，只需对前者解除一次引用，但需要对后者解除两次引用

```C++
#include <iostream>

using namespace std;

int main()
{
    int n[3] = {1, 2, 3};
    int *pn = n;

    cout << n[1] << endl;
    cout << pn[1] << endl;
    cout << *(n + 1) << endl;
    cout << *(pn + 1) << endl;

    cout << &n[1] << endl;
    cout << &pn[1] << endl;
    cout << (n + 1) << endl;
    cout << (pn + 1) << endl;

    cout << n << endl;
    cout << n + 1 << endl;
    cout << &n << endl;
    cout << &n + 1 << endl;
    cout << pn << endl;
    cout << pn + 1 << endl;
    cout << &pn << endl;
    cout << &pn + 1 << endl;

    return 0;
}
//20221117_数组与指针2.cpp
```

- 更多程序见 20220930_数组与指针1.cpp 与 201120_数组与指针2.cpp
- 数组名虽然是数组第一个元素的地址，但它本质上还是个常量，不能修改其值；而指向数组的指针是个变量，因此可以进行指针意义下的加减操作进而更新指向
- 对数组名应用 sizeof 运算符得到的是整个数组的长度(以字节为单位)，而对指向数组的指针应用 sizeof 运算符得到的是指针所占内存空间的长度，即使此时指针指向的是一个数组。即在这种情况下，C++不会将数组名解释为地址
- 对数组名应用地址运算符时，得到的将是整个数组的地址(整个数组长度)，而不是数组中第一个元素的地址
- 对于字符数组要特别注意：在 cout 和多数C++表达式中， char数组名 、 char指针 以及 用引号括起的字符串常量 (存储在静态只读区)都被解释为字符串第一个字符的地址，它们传递给 cout 时，**将打印该地址处的字符，然后继续打印后面的字符，直到遇到空字符为止**。见下面的代码分析：
  
```C++
#include <iostream>

using namespace std;

int main()
{
    char flower[10] = "rose";
    int num[10] = {1, 2, 3};

    cout << flower << endl; //输出rose，因为flower是字符数组
    cout << num << endl; //输出0x62fdf0，因为num是整型数组名，本质上是个指针
    cout << num[0] << endl; //输出1，num[0]是数组中的第一个元素

    return 0;
}
``` 

- 更多内容见C++ Primer Plus 4.8.3小节

### :rocket: **在查看输入方面， cin >> ch 、 cin.get(ch) 、 ch = cin.get()有什么异同 ？**

| 属性| cin.get(ch) | ch = cin.get() |
| :---------: | :---------: |:---------: |
| 传递输入字符的方式 | 赋给参数ch | 将函数返回值赋给ch |
| 用于字符输入时函数的返回值 |  istream 对象(执行 bool 转换后为 true )，因此可以有用法 cin.get(ch1).get(ch2)  |  int 类型的字符编码，与C语言中函数getchar()相似 |
| 到达文件尾时函数的返回值 |  istream 对象(执行 bool 转换后为 false ) | 文件尾EOF |

-  cin >> ch 读取时，读入时使用空白(回车、制表符、换行符)来确定字符串的结束位置，会自动过滤这些空白，遇到后停止读入；**即不会读入这些空白，但并不会将它们从输入队列中删除，在连续进行多个输入时要注意(见C++ Primer Plus P81 程序清单4.6)**；并且之后当用户按下回车键之后，输入的内容才会被发送给程序，进入缓冲；读入完成后， cin 自动在字符串的结尾添加空字符
- 若 cin >> ch 输入内容的类型与存储内容的类型不匹配，将发生：变量 ch 的原内容保持不变、不匹配的输入仍然保留在输入队列中、 cin 对象中的一个错误标记被设置(即读入功能被禁用)、对 cin 方法的调用将返回 false (如果被转换为 bool 类型)(输入错误、输入类型不匹配、文件尾EOF都将导致 cin 返回 false )

```C++
#include  <iostream>

using namespace std;

int main()
{
    int num1, num2;
    cout << "First number" << endl;
    cin >> num1;

    cin.clear(); //当输入类型与存储类型不匹配cin读入功能被禁用时重置输入
    while(cin.get() != '\n'); //消耗类型不匹配的输入，以便进行接下来的输入

    cout << "Last number" << endl;
    cin >> num2;

    cout << "num1 = " << num1 << " , num2 = " << num2 << endl;

    return 0;
}
```

-  cin.get(ch) 在读取字符时，将读取输入中的**下一个字符(即使它是空格)**，并将其赋给变量 ch ，这在一定程度上弥补了用法 cin >> ch 的缺陷
- 到现在，已经接触过 get() 的四种不同用法： cin.get() 、 ch = cin.get() 、 cin.get(ch) 、 cin.get(Name, ArSize) 

### :rocket: **switch 与 if else 有什么异同？**

- 两者都允许程序从选项中进行选择，但相比之下 if else 更加通用
- 例如只有 if else 可以处理**取值范围**问题，而 switch 中的每一个 case 标签都必须对应一个整数(含 char )，因此 switch 无法处理浮点数测试。另外 switch 标签值还必须是常值，无法处理变量的比较或选择问题
- 当然如果所有的选项都可以使用整数常量来表示，且数量多于3个时，就代码长度和执行效率而言， switch 将更加高效

```C++
#include <iostream>
#include <string>
#include <cctype>

using namespace std;

//判断读入的字符是否为元音字母开头
int main()
{
    string words;
    int vowels = 0, consonants = 0, others = 0;

    while (cin >> words)
    {
        if (isalpha(words[0]))
        {
            switch(words[0]) //这里如果要用if结构则需要有十个条件表达式
            {
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u':
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U': 
                    vowels++;
                    break;
                default: 
                    consonants++;
            }
        }
        else
        {
            others++
        }
    }

    return 0;
}
``` 

### :rocket: **break 与 continue 有什么异同？**

-  break 既可用在循环中，又可用在 switch 中，而 continue 只可用在循环中
- 当 break 用在循环中时，表示立刻结束循环，转而执行循环体之外的语句；而 continue 用在循环中时，表示跳过循环体剩余部分(即不会跳过 for 循环的更新表达式)，转而执行下一次循环
- **当 break 用在 switch 中时，表示跳过 break 之后的所有 case** 

### :rocket: **关键字 const 与指针相结合的三种不同用法有何区别？**

- 用法 const int *pt; 表示 pt 指针可以指向任意 int 类型的变量，但不能通过该指针修改所指向对象的值( const int 限定)，但是这并不代表所指向对象必须是常量，即可以直接通过变量来修改其值，但不能通过 pt 指针修改
- 用法 int *const pt; 表示不能修改 pt 指针以指向其他对象，但是可以通过指针修改当前所指向对象的值
- 用法 const int *const pt; 表示既不能修改 pt 指针以指向其他对象，也不能通过该指针修改所指向对象的值
- 前两种用法的主要区别是关键字 const 与 * 的相对位置关系：若 const 在前表示 *pt 为只读， const 在后表示 pt 为只读
- 如果数据类型不是指针(数组名)(即数据类型与指针之间只有一层间接关系)，则可以将 const 数据或非 const 数据的地址赋给指向 const 的指针，但只能将非 const 数据的地址赋给非 const 指针。因此为了使函数应用范围更广，应将指针形参声明为指向 const 的指针

```C++
const int months[3] = {31, 28, 19};
int sum(int arr[], int n);
int j = sum(months, 3); //报错，编译器不允许将 const 指针赋给非 const 指针
```

- 更多内容见C++ Primer Plus 7.3.5 小节

### :rocket: **使用关键字 auto 进行自动类型推断时需要注意什么问题？**

- 使用 auto 定义的变量必须有初始值，因为它是让编译器通过初始值来判断变量的类型的
- 使用 auto 也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始数据类型都必须一样
- 当引用被用作初始值时，真正参与初始化的是引用对象的值(与 decltype 相区别)，此时编译器以引用对象的类型作为 auto 变量的类型
- auto 一般会忽略掉顶层 const，但底层 const 会保留下来
- auto 只能用于单值类型推断，而不能使用初始化列表
- 当用初始化列表初始化数组时，仅当列表中含有单一的初始化器才可以使用 auto
- **auto 可以用于函数返回类型，即把函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置 auto**

```C++

auto p1 = new auto(obj); //p1指向一个与obj类型相同的对象
auto p2 = new auto{a, b, c}; //错误，括号中只能有单个初始化器

// 声明返回一个指向具有10个整型元素数组的指针
auto func(int i) -> int(*)[10];
```

- 参考链接：https://zhuanlan.zhihu.com/p/343507680

### :rocket: **关键字 auto 与关键字 decltype 在类型推断时有何区别？**

### :rocket: **左值与右值有何区别？**

- 左值是**可以取地址**的数据对象(如变量、数组元素、结构成员、引用和解除引用的指针)，即常规变量和 const 变量都可视为左值，因为可以通过地址访问它们，但非 const 常规变量属于可修改的左值，而 const 变量属于不可修改的左值，左值一般存放在内存之中
- 右值分为纯右值和将亡值，纯右值包括字面常量(**用引号括起的字符串除外，它们由其地址表示**)和包含多项的表达式，将亡值包括匿名对象，右值一般存放在寄存器中
- 赋值语句的左边必须是可修改的左值，即左边的子表达式必须标识一个可修改的内存块，如返回类型为引用的函数。常规函数(返回类型为非引用)的返回值为右值，因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在
- 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值表达式的例子，而返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都是返回右值表达式的例子(区分前置/后置运算符)
- **左值引用绑定到左值上，右值引用绑定到右值上，而 const 左值引用既可以绑定到左值上，也可以绑定到右值上，其中要注意的一点是右值引用类型的变量本身是左值，因此不能将右值引用绑定到右值引用的变量上**
- 程序实例详见 20230620_左值与右值.cpp 与 20230621_左值引用与右值引用.cpp

### :rocket: **C++中为什么要引入右值的概念，移动构造函数是如何实现的？**

- **首先最重要的原因是为了效率，在一些重新分配内存资源的类中，从旧内存中将元素移动到新内存中、而不是拷贝到新内存中可以提高程序效率；另外还有一个原因是 IO 类或 unique_ptr 类的对象不能拷贝，因此只能移动**
- 当传入的形参为右值时，若该类不存在移动构造函数，由于 const 类型的左值引用可以绑定到右值，则根据函数的重载也会调用拷贝构造函数；若该类存在移动构函数，则会优先调用移动构造函数，此时移动构造函数是该调用的最佳匹配。因此可以通过重载拷贝构造函数和移动构造函数来实现移动操作，**区别在于拷贝构造函数不会修改源对象，而移动构造函数可能会修改源对象，使得源对象处于可析构状态**
- 除了完成资源移动，移动构造函数还必须确保移后源对象处于一种可析构的状态，即移动后源对象的析构函数必须能够安全地销毁对象，特别是移后源对象不能再指向被移动的资源，这些资源的所有权已经归属于新创建的对象
- 移动构造函数在参数列表和成员初始化列表之间的关键字 noexcept 不可以被省略，这是在通知标准库移动构造函数不会抛出异常。因为当在对象移动的过程中有可能发生异常，此时旧空间中的移动源元素被改变了，而新空间中未构造的元素尚不存在，使用移动构造函数就会产生问题，问题在于它不能满足自身保持不变，而使用拷贝构造函数可以释放新分配但还未构造的内存空间并返回，源对象仍然存在，但这样会使效率降低，违背移动构造函数的本意。
- 如果希望在重新分配内存的过程中使用移动构造函数而不是拷贝构造函数，就必须显示地告诉标准库移动构造函数不会抛出异常可以安全使用，也就是用关键字 noexcept 来做到这一点。如果移动构造函数使用了关键字 noexcept，但在移动时抛出了异常，程序会调用函数 std::terminate() 来终止运行

### :rocket: **万能引用/引用折叠是如何实现的？**

- 形如`T &&`、一般出现在函数模板类型参数中的引用称为万能引用
- 当将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数(即`T &&`)时，编译器推断模板类型参数为实参的左值引用类型，即 T 的类型为 int &，而非int，最终该函数的参数为`T& &&`(定义了引用的引用)
- 如果间接创建了引用的引用，则这些引用形成了“折叠”，即：类型X& &、X& &&、X&& &都会折叠成 X&，类型 X&& && 会折叠成 X&&，其中 X 为任意给定类型
- 引用折叠只能用于间接创建的引用的引用，如类型别名或函数模板

### :rocket: **右值引用有什么作用？**

- 右值引用是C++11引入的特性，它是指对右值(纯右值、将亡值)进行引用的一种方式。右值引用的作用主要有以下两个：
- 右值引用可以用来实现**移动语义**。移动语义可以在不进行深拷贝的情况下，将对象的资源所有权从一个对象转移到另一个对象，从而提高代码的效率
- 右值引用还可以用于**完美转发**。在函数模板中，通过使用右值引用类型的形参来接收参数，可以实现完美转发，即保持原参数的值类别(左值还是右值)不变，将参数传递给另一个函数

### :rocket: **如何区分值类别与值类型？**

- 值类别指的是表达式的值的类别，即左值还是右值；值类型指的是表达式的类型，即 int 还是 double 或其他自定义类型
- 例如：值类型为 int 可能是左值，如声明为 int 的变量；也可能是右值，如字面值常量10

### :rocket: **std::move() 是如何实现的？**

- 使用类型转换运算符 static_cast 来实现，static_cast 可以将左值转换为右值引用，但不能将右值转换为左值引用，因此 std::move() 可以将左值转换为右值引用，但不能将右值转换为左值引用

```C++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	return static_cast<typename remove_reference<T>::type&&>(t);
}
```

- move() 函数的参数 T&& 是一个指向模板类型参数的右值引用，通过引用折叠，此参数可以与任意类型的实参匹配。特别是，既可以传递给该函数一个左值，也可以传递给它一个右值

```C++
string s1("Hi"), s2;
s2 = std::move(string("bye")); //正确，从一个右值移动数据
// 1.推断出T的类型为string
// 2.remove_reference用string实例化
// 3.remove_reference<string>的type成员为string类型
// 4.因此move函数返回的类型为string&&
// 5.move的函数参数t的类型为string&&，不会发生引用折叠
// 6.类型转换什么也不做，因为此时t的类型已经是string&&

s2 = std::move(s1);
// 1.推断出T的类型为string &，而非普通的string类型
// 2.remove_reference用string &实例化
// 3.remove_reference<string &>的type成员为string类型
// 4.因此move函数返回的类型为string&&
// 5.move的函数参数t的类型为string& &&，通过引用折叠为string &
// 6.static_cast<string&&>(t)将左值引用转换为右值引用
```

### :rocket: **完美转发是如何实现的？**

```C++
template <typename Type>
intermediary(Type&& arg)
{
    finalFcn(std::forward<Type>(arg));
}
```

- 如果实参是一个右值，则 Type 是一个普通(非引用)类型，forward< Type> 将返回 Type&&，因此 finalFcn 将获得一个右值引用。如果实参是一个左值，则通过引用折叠，Type 本身是一个左值引用类型，在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 forward< Type> 的返回类型进行引用折叠，将返回一个左值引用类型

### :rocket: **为什么在引用参数作形参时应可能使用 const ？**

- 使用 const 可以避免无意中修改数据的编程错误，若在函数中无意修改，则程序会发出警告或报错
- 使用 const 引用使函数能够处理 const 和非 const 实参，否则将只能接受非 const 数据，这是因为引用必须是变量的引用
- 使用 const 引用使函数能够正确生成并使用临时变量，如果实参与形参类型不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值

```C++
#include <iostream>
#include <string>

using namespace std;

string version1(const string &s1, const string &s2);

int main()
{
    string input;
    string result;

    cout << "Enter a string: ";
    getline(cin, input);

    result = version1(input, "***");

    return 0;
}

string version1(const string &s1, const string &s2)
{
    string temp;

    temp = s2 + s1 + s2;
    return temp;
}
```

- 为了不修改字符串 input 中的值，函数的第一个形参使用 const 引用，调用函数时的第一个实参是 string 类型，因此让 s1 指向它没有任何问题
- 对于函数中的第二个形参， string 类定义了一种 char * 到 string 的转换功能，这使得可以使用C-风格字符串来初始化 string 对象(因为用引号括起的字符串常量值的本质是指向字符的指针，即 char * 类型)；但 string 类型为常量，正因为使用了 const 引用，函数将在实参与形参类型不匹配时创建一个正确类型的临时变量，使用转换后的实参值来初始化临时变量，然后传递一个指向该临时变量的引用
- 该函数中的 temp 变量只在函数内部有效，函数执行完毕之后它将不再存在，因此返回指向 temp 的引用不可行。在按值传递的过程中， temp 的内容将被复制到一个临时的存储单元中，然后在 main() 函数中，该存储单元的内容被复制到一个名为 result 的 string 中
- **综上所述，如果形参的类型为 const string & ，在调用函数时使用的实参可以是 string 对象或C-风格字符串，包括用引号括起的字符串常量、以空字符结尾的 char 数组或指向 char 的指针变量**
- **另外一个应用 const 类型的引用的地方是在拷贝构造函数之中，如果传入右值且该类没有移动构造函数，那么 const 类型的引用也能够绑定到左值，进而调用拷贝构造函数**

### :rocket: **关键字 const 与 static 之间有什么异同？**

- const 与 static 都是C++的关键字，都可以用来修饰函数或变量
- const 表示只读语义，表示运行时不可修改，const修饰的变量有三种：const 对象、const 指针、const 引用，根据它修饰的具体对象来决定不可变的对象是什么以及具体的操作有哪些。因为 const 对象一旦创建之后就不能再改变，所以必须初始化，而不能只定义
- static 表示静态存储，**被 static 修饰的变量会修改它的声明域和存储方式**，但不改变作用域，局部变量还是作用于局部，全局变量依然作用于全局，但均被默认初始化为0，它们从声明开始，就一直存在到程序运行结束，因为它们处于静态存储区
- const 修饰的变量能且只能在定义的同时进行初始化，程序运行时不能改变其值，当 const 修饰函数的形参时，既可以接收 const 类型的实参，又可以接收非 const 类型的实参；而 static 变量可以在程序运行期间多次赋值或改变其值
- 因为C++是类特性鲜明的语言，所以 const 和 static 又有另外意义。被 const 修饰的成员函数表明它不会修改调用对象的内容(mutable 修饰的变量除外)，一般被修饰的函数都是只读取信息的函数，**且可以访问类的所有成员**，包括静态成员和非静态成员，const 对象不可以调用非 const 成员函数；而被 static 修饰的成员函数不再为某一个类对象所拥有，而是被类特有，可以通过类对象或类型的方式调用静态成员函数，且这种函数只可访问静态成员，函数形参列表中不存在隐藏的 this 指针，**不可访问非静态成员(包括成员函数和成员变量)，不能被声明为 const、虚函数和 volatile**
- **被 static 修饰的成员变量不属于任何一个类对象，必须在类定义的外部初始化，初始化时不需要使用关键字 static，且可以被任意非 static 成员函数访问；被 const 修饰的成员变量不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化**

### :rocket: **关键字 const 的考点汇总**

- 默认情况下，const 对象被设定为仅在文件内有效，当多个文件中出现了同名的const 对象时，其实等同于在不同文件中都分别定义了独立的变量。**当希望在一个文件中定义、多个文件中使用 const 对象时，需要在定义 const 对象时加上 extern 关键字，以使得const对象在多个文件中都有效**
- 引用只能绑定在对象上，但不能与某个字面值或表达式的计算结果绑定在一起。但在**初始化常量引用时允许使用任意表达式作为初始值，只要该表达式可以转换为引用的类型即可，尤其是允许为一个常量引用绑定非常量的对象、字面值甚至是个一般表达式**
```C++
int &refVal = 10; // 错误，引用必须绑定在对象上
double dVal = 3.14;
int &refVal2 = dVal; // 错误，引用类型必须与其绑定的对象严格匹配

int i = 42;
const int &r1 = i; // 正确，允许将一个引用常量绑定到非常量对象上
const int &r2 = 42; // 正确，允许将一个常量引用绑定到字面值上
const int &r3 = r1 * 2; // 正确，允许将一个常量引用绑定到一个表达式上
int &r4 = r1 * 2; // 错误，r4是普通的非常量引用
```
- 常量指针可以指向非常量对象，常量引用可以绑定非常量对象，含义是都不能通过指针或引用修改所指向或绑定对象的值，但该对象自身不一定是个常量
- 顶层 const 可以表示任意的对象是个常量，这一点对任何数据类型都适用；而底层 const 则与指针、引用等复合数据类型有关。指针类型既可以是顶层 const ，也可以是底层 const ，或者两者都是，或者两者都不是；**而引用只能是底层 const ，不存在顶层 const 的引用，因为引用不是对象**
- 不能忽视底层 const 在执行对象的拷贝操作时的限制。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够进行转换。一般来说，非常量可以转换为常量，反之则不行

```C++
int i = 0;
int *const p1 = &i; //顶层const
const int ci = 42; //顶层const
const int *p2 = &ci; //底层const
const int *const p3 = p2; //既有顶层const，又有底层const
const int &r1 = ci; //引用只能是底层const

i = ci; //顶层const对赋值操作无影响
p2 = p3; //正确，p2与p3所指向的对象类型相同，顶层const无影响

int *p = p3; //错误，p3包含底层const的定义，而p没有
p2 = &i; //正确，int * 能转换成const int *
int &r2 = ci; //错误，非常量引用不能绑定到常量对象上
```

### :rocket: **关键字 const 修饰的变量在C语言与C++中有何异同？**

- 首先在两种语言中，被 const 修饰的变量不能够再作为左值，即初始化完成之后，其值不能再被修改
- 在C语言中，应该将被 const 修饰的变量看作常变量，其本质上还是一个变量，因此不要求其在定义时就赋予初值，但因为 const 修饰的原因，如果在定义时不赋予初值，以后也就不能再使用了；另外，由于变量的本质，即使在定义时被赋予了初值，但不能作为数组的大小来定义数组
- 在C++中，被 const 修饰且用变量进行初始化的变量看作常变量，与**在C语言中相区别的是，其能作为数组的大小来定义数组**
- 在C++中，被 const 修饰且用字面值常量进行初始化的变量看作常量，在编译阶段，编译器就会将所有出现const常量名字的地方替换为该字面值常量，所以可以作为数组的大小来定义数组；即使通过指针修改了原内存块地址处的值，但因为早已进行了替换，所以最终输出还是字面值
- 程序实例见 20230521_const在C++中的应用.cpp、20230521_const在C++中的应用2.cpp、20230521_const在C语言中的应用.c

### :rocket: **Lambda 表达式是什么？与普通函数有何异同？**

- **Lambda表达式是一类可调用对象**，C++中共有五种可调用对象：函数、函数指针、重载了函数调用运算符 operator() 的类(也称为函数符)、使用库函数 bind() 创建的对象、Lambda表达式
- Lambda表达式是C++11新增的一种形式，表示一个可调用的代码单元，可以将其理解为一个**匿名的内联函数**，语法格式如下所示。其中 capture list(捕获列表)是lambda**所在函数中定义的局部非 static 变量**的列表，parameter list 是参数列表，return type 是返回类型，function body 是函数体。**具体实现时可以省略参数列表与返回类型，但必须包含捕获列表与函数体**
```C++
 [capture list](parameter list) -> return type { function body }
 auto f = [] {return 42;};
 // 空捕获列表表示此lambda表达式不使用它所在函数中的任何非static局部变量
```
- 与普通函数的声明方式不同：Lambda表示在定义时不需要指定函数名
- 与普通函数的返回类型不同：Lambda表达式可以省略返回类型，也可以由编译器根据函数体中的代码推断返回类型；在默认情况下如果一个Lambda表达式包含一个 return 之外的任何语句，则编译器假定此Lambda返回类型为void；若要为Lambda表达式显式地声明返回类型，**必须使用尾置返回类型**，即 -> return type。而普通函数必须声明返回类型，不能省略，但对于复杂类型可以使用 auto 自动类型推断尾置返回类型
- 与普通函数的作用域不同：Lambda表达式的**捕获列表只能用于局部非 static 变量**，因为它可直接访问局部 static 变量和在它所在函数之外声明的变量；而普通函数需要通过参数传递或全局变量来访问其他作用域中的变量
- 与普通函数的形参列表不同：Lambda表达式的**形参列表中不能有默认参数**，一个Lambda调用的实参数目永远与形参数目相等；而普通函数中可以有一个或多个默认参数，且默认参数必须放在形参列表的右侧位置
- 与普通函数的编译器实现不同：**Lambda表达式的类型是在编译期间生成的，而普通函数的类型是在链接期间生成的。因此，Lambda表达式的类型可直接嵌入其他类型中，如容器和算法；而普通函数则需要使用函数指针或函数对象**
- Lambda表达式的使用更加灵活、简洁，在函数对象、回调函数、泛型编程等场景中具有广泛的应用。但是，在使用Lambda表达式时，应注意避免过多的捕获和复杂的语句块，以保证代码的可读性和维护性

### :rocket: **叙述内联函数如何实现及注意要点？**

- 在大多数机器上，一次函数调用可能包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；有可能需要拷贝实参；程序转向一个新的位置执行
- 为了消除这些开销，在函数的返回类型之前使用关键字 inline，可以要求编译器在每个调用点上“内联”展开函数代码。内联函数一般在声明处展开函数体
- **内联函数的执行速度比常规函数稍快，但代价是需要占用更多的内存空间**。因此内联函数只适用于规模较小、频繁调用、流程简明直接的函数
- 一般情况下所有函数都可以设为内联函数，但内联函数只是向编译器发出的一个请求，编译器可以选择忽略此请求，可能是编译器觉得此函数规模过大或此函数发生了递归调用(内联函数不能递归)
- 综上，应该有选择的使用内联函数，如果函数调用机制的开销比函数本身执行的开销要大，而且函数频繁发生调用的话，可以考虑使用内联函数。**但是，内联函数的定义必须放在头文件中，否则编译器无法在调用点展开函数体，导致链接错误**

### :rocket: **叙述函数指针的定义及用途？**

- 与普通内置类型指针一样，函数指针中存放的是函数的地址，也就是函数机器语言代码的内存的开始地址
- 声明函数指针需要指明其所指向的函数类型，**函数类型由函数的返回类型与形参列表共同确定，而与函数名无关**

```C++
// 优先级：圆括号 > 方括号 > 取内容运算符
double *pf(int); //声明一个指针函数，其返回类型为double*，形参列表为int
double (*pf)(int); //声明一个函数指针，其所指向的函数返回类型为double，形参列表为int
```

- C++中允许像使用函数名一样直接使用函数指针，如下所示，这种用法与数组名与数组首元素的关系类似
```C++
double pam(int);
double (*pf)(int);
pf = pam; //pf指向pam函数
double x = pam(4);
double y = pf(5); //合法使用
double z = (*pf)(5); //合法使用
```

- **要深刻理解函数指针，最关键的还是要牢记运算符优先级：圆括号 > 方括号 > 取内容运算符**，程序实例详见20221126_运算符优先级1.cpp、20221215_运算符优先级2.cpp

### :rocket: **叙述函数重载相关内容？**

- 在同一作用域内名字相同而形参列表不同的函数构成函数重载。这里要注意函数的类型包括返回值类型与形参列表，而形参列表中又包括形参类型和形参个数，所以**名字相同且只有返回类型不同的函数不构成函数重载**，main 函数不能重载
- 一个拥有顶层 const 的形参无法与另一个没有顶层 const 的形参区分开来，如下所示，而**如果形参是某种类型的引用或指针，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 const 是底层的**
```C++
Record lookup(Phone);
Record lookup(const Phone); //重复声明

Record lookup(Account&);
Record lookup(const Account&); //重载
```
- **类的成员函数有无 const 修饰也构成重载**，本质是指向调用该函数的 this 指针的底层 const 属性不同，即 this 指针所指向的该类的对象是否为常量对象
- 程序实例详见 20230608_成员函数中的函数重载.cpp

### :rocket: **关键字 inline 与 define 之间有什么异同？**

![](../picture/内联与宏.png)
- 宏定义是在**预处理阶段**进行的，执行的是类似于**文本替换**的功能；而内联函数是在**编译阶段**进行的，本质上还是一个函数，**可以进行按值传递、类型检查与转换、代码生成等操作**
- 宏定义是内联函数早期在C语言中的版本实现，如果使用宏实现了类似函数的功能，要替换为内联函数

### :rocket: **如何理解 extern C ？**

### :rocket: **函数在调用时栈会发生什么变化？**

### :rocket: **C++11新特性有哪些？**

- auto 自动类型推断
- 范围 for 循环语句
- 更加丰富智能指针：shared_ptr、unique_ptr、weak_ptr，库函数make_shared、make_unique
- 新的STL容器：array、forward_list、unordered_map、unordered_set、unordered_multimap、unordered_multiset
- 右值引用与移动语义
- 列表初始化、新的类型

### :rocket: **#include <> 与 #include "" 有何异同？**

- 两者都是C++文件中用于包含头文件的方式。预处理器发现`#include`指令后，会就寻找指定的文件，然后将文件内容替换到`#include`指令所在的位置，就像把被包含文件中的全部内容键入到源文件中的这个位置一样。但是两者搜索文件的路径不同
- `#include <>`用于包含标准库头文件，搜索标准库头文件的路径由编译器实现定义，一般来说，编译器会搜索某些标准目录，如`/usr/include`和`/usr/local/include`，但是具体的实现依赖于编译器，可以通过设置搜索路径环境变量或命令行选项来修改这些目录
- `#include ""`用于包含用户自定义头文件，一般来说，编译器会搜索当前文件目录或源文件所在的目录或文件名指定的其他目录，然后再搜索某些标准目录，如`/usr/include`和`/usr/local/include`

### :rocket: **自定义头文件 test.h 中的语法结构是什么样的？为什么要这样做？**

- 自定义头文件 test.h 中的语法结构如下：
```C++
#ifndef __TEST_H__ //如果没有定义__TEST_H__，则执行下面的语句
#define __TEST_H__

#endif
```
- 为了防止头文件被重复包含，因为头文件中可能包含全局变量、函数、类等，如果被重复包含，会导致重复定义，从而出现链接错误(重定位时出现不止一处)

## 内存管理

### :rocket: **new、delete 的工作原理是怎样的？**

- new：先开辟内存空间，后构造对象
![](../picture/new的工作原理.png)
- delete：先析构对象，后释放内存空间
![](../picture/delete的工作原理.png)
![](../picture/new与delete的搭配使用.png)

### :rocket: **new/delete 和 malloc/free之间有什么异同？**

```C++
int *p = new int[2];
int *q = (int *)malloc(2 * sizeof(int));
```

- new 和 malloc 都可以用于内存的动态申请，delete 和 free 都可以用于内存的释放
- new/delete 是C++中的运算符，而 malloc/free 是C语言头文件 stdlib.h 中的库函数
- new/delete 操作时直接针对具体类型的指针，而函数 malloc 返回 void* 类型的指针，在赋给其他指针类型时需要进行类型转换
- new 将内存分配与对象构造组合在一起，因此会调用构造函数，而 malloc 智能分配内存，不能调用构造函数；delete 将对象析构和内存释放组合在一起，因此会调用析构函数，而 free 不能调用析构函数
- delete 或 free 仅仅是告诉操作系统，这一块内存被释放了，即用户最好不要再使用。但是由于没有重新对这块内存进行写操作，所以内存中的内容**有可能**是垃圾值，**并且两者都不会销毁指针，指针不会指向空，进而出现野指针的情况。因此，释放完内存后应该将该指针显式地置为空**
- 对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete，这就涉及到了运算符的重载
- **C++允许用户对new、new[]、delete、delete[]进行运算符重载(C++ Primer P491)**
- 程序实例详见 20230318_free和delete怎样处理指针1.c、 20230318_free和delete怎样处理指针2.cpp、20230627_free和delete怎样处理指针3.cpp、20230628_free和delete怎样处理指针4.cpp

### :rocket: **new 和 malloc 有什么异同？**

- 分配内存的位置：**malloc 是从堆上动态分配内存，new 是从自由/开放存储区为对象动态分配内存**。自由存储区的位置取决于 operator new 的实现。**自由/开放存储区不仅可以为堆，还可以是静态存储区，这都看 operator new 在哪里为对象分配内存**
- 返回类型安全性：malloc 内存分配成功后返回 void*，然后再强制类型转换为需要的类型；而 new 操作符分配内存成功后直接返回与对象类型相匹配的指针类型，**因此 new 是符合类型安全的操作符**
- 内存分配失败返回值：malloc 内存分配失败后返回NULL，而 new 分配内存失败则会抛异常(bad_alloc)，因此需要进行异常捕获
- 分配内存大小的计算：使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的大小
- 内存扩容机制：new 无扩容机制，malloc 通过 realloc 扩容
- 是否可以被重载：new、delete、new[]、delete[] 可以被重载，而 malloc/free 本身是库函数，不能重载

### :rocket: **如果 new 分配内存失败会怎样？**

- 一般情况下分配内存失败会抛出异常(bad_alloc)
- 但是如果使用了 std::nothrow 关键字，则分配内存失败会返回空指针(NULL)，而不会抛出异常
```C++
A *pa = new(std::nothrow) A;
```

### :rocket: **new 是在内存上哪一块分配的内存？**

- new 所申请的内存区域在C++中称为自由/开放存储区。很多编译器的 new/delete 都是以 malloc/free 为基础来实现的，所以通常都是借由堆实现来实现自由存储，这时候就可以说 new 所申请的内存区域在堆上

### :rocket: **如何只在栈上分配内存、创建对象？**

- 重载 new 运算符并设为私有权限

### :rocket: **指针与引用之间有什么异同？**

- **指针是对象，而引用不是对象**。因此可以定义指针的指针、指针的引用、存放指针的数组、指针常量，但不能定义引用的引用、引用的指针、存放引用的数组、引用常量

```C++
int i = 42;
int *p; // p是一个指向int型变量的指针
int *&r = p; // r是一个绑定指针p的引用
r = &i; // r引用了指针p，因此给r赋值&i就是令p指向i
*r = 0; // *r是i的别名，解引用得到i，因此给*r赋值0就是令i的值变为0

int **q; // q是一个指向指针的指针
q = &p; // q指向p

int *a[10]; // a是一个含有10个指针的数组
int (*b)[10] = &a; // b是一个指向含有10个整数的数组的指针

int *const s; // s是一个指向int型变量的常量指针(顶层const)
const int *t; // t是一个指向int型常量的指针(底层const)
```

- 可以把引用理解为类型的别名，因此引用必须被初始化，而指针不必，即存在空指针，但不存在不绑定任何对象的引用
- 除常量指针之外，指针在其生命周期之内可以更改所指向的对象，也允许拷贝和赋值，**但无法令引用重新绑定到另外一个对象**

```C++
int iVal1 = 10;
int iVal2 = 20;
int &refVal1 = iVal1;
int &refVal2; // 错误：引用必须绑定到对象
int &refVal3 = refVal1; // 正确：refVal3绑定到了那个与refVal1绑定的对象上，此处就是绑定到了iVal1上
refVal3 = 15; // 正确：refVal3是iVal1的别名，因此refVal3 = 15就是iVal1 = 15
&refVal3 = iVal2; // 错误：无法令引用重新绑定到另外一个对象
```

- 指针和引用都实现了对其他对象的间接访问，使用引用所绑定的对象时可以像使用变量一样使用引用，而使用指针所指向的内容时需解引用

### :rocket: **指针常量与常量指针有何区别？**

- 指针常量指的是指针本身是一个常量，具有顶层 const，即不能改变指针指向其他对象，但可以通过指针修改所指向对象的值
- 常量指针表示不可以通过指针修改所指向对象的值，具有底层 const，但可以更改指针以指向其他对象。**至于所指向的对象到底是不是常量，应该视该对象而决定，如果该对象不是常量，那么可以通过其他途径修改该对象的值，只不过不能通过常量指针修改而已**

### :rocket: **指针函数与函数指针有什么区别？**

- 指针函数即返回指针的函数，本质上是一个函数
- 函数指针即指向函数的指针，本质上是一个指针
- 区分以上两者最重要的还是区分运算符优先级：圆括号 > 方括号 > 取内容运算符

```C++
int *func(int); // 指针函数，返回指针
int (*func)(int); // 函数指针，指向函数
```

### :rocket: **如何访问一个给定物理地址的内存空间？**

- 方法一：使用定位 new 运算符

```C++
int data = 0;
int *p8 = new (&data) int(1); //在data的地址上构造一个int对象
// 定位new表达式允许用户向new传递额外的参数，这些参数被传递给operator new函数
cout << "*p8 = " << *p8 << endl;
cout << "data = " << data << endl;
```

- 方法二：使用函数指针。先定义函数指针类型，然后将所给物理地址通过强制类型转换转化为该类型，赋给一个同样函数指针类型的变量，最后通过该函数指针变量调用的方式访问该物理地址上的内存空间

### :rocket: **空指针、野指针、悬垂指针各是什么？**

- 一般将等于`0/NULL/nullptr`的指针称为空指针，空指针是不指向任何对象的指针，**空指针不能被解引用，但是可以定义指向空指针的指针**，即对空指针取地址。一般在释放内存空间之后，要对指向这块内存空间的指针显示地置空
- 野指针是指向非法内存区域的指针，可能指向一个已经释放的内存地址，可能指向一个未分配的内存地址，也可能指向一个未初始化的内存地址，野指针是危险的，因为它指向的内存可能已经被其他程序使用，所以对野指针的解引用操作可能会导致程序崩溃
- 悬垂指针是指所指向的内容已被释放，指针指向的对象的声明周期已结束，但指针本身仍然存在，悬垂指针是危险的，因为它指向的内存可能已经被其他程序使用，所以对悬垂指针的解引用操作可能会导致程序崩溃

```C++
int *p = NULL; // 空指针
*p = 42; // 错误：不能解引用空指针
int **pp = &p; // 正确：可以定义指向空指针的指针

int *q; // 野指针，未被初始化的指针
*q = 42; // 错误：不能解引用野指针

int *r = new int(42);
delete r;
*r = 1024; // 悬垂指针，指针所指向的对象已被释放

int *s = nullptr;
{
    int i = 42;
    p = &i;
}
*p = 1024; // 悬垂指针，指向的对象的声明周期已结束
```

- 要解决以上问题，可以从以下几点入手：**在解引用指针之前，要判断指针是否为空；对于定义的指针，一定要进行初始化；指针指向的对象的生命周期结束后，要将指针显式地置为空；要注意长生命周期的指针不能指向短生命周期的对象；C++ 11 之后尽量使用智能指针**

### :rocket: **深拷贝与浅拷贝之间有什么异同？**

- 浅拷贝和深拷贝其实是**针对被拷贝对象是否存在指针成员的情况**而言的
- 当存在指针成员而且浅拷贝发生，就会使得指针被拷贝一份但指针指向内容没有拷贝，也就是**它们指向的内容是同一份，会存在内存释放时造成内存泄漏的风险**，而两个对象被释放也会因为两次调用delete，而实际指向内容只有一份而程序崩溃
- 深拷贝就是基于上述可能发生的内存泄漏情况，首先开辟属于自身的内存空间，然后把指针指向的内容拷贝到自身的内存空间中，一个类要实现深拷贝就要实现拷贝构造函数和赋值运算符重载函数
- 程序实例详见 20230103_深拷贝与浅拷贝 

### :rocket: **如何理解C++中的四种智能指针?**

- 首先说⼀下为什么要使用智能指针：智能指针的作用是**管理⼀个原内置指针所指向的堆上的动态内存空间**，避免程序员在函数结束时忘记释放申请的内存空间，进而造成内存泄漏情况的发生。使用智能指针可以很⼤程度上避免该问题，**因为智能指针就是⼀个类，当智能指针对象超出了对象的作用域时，类会自动调用析构函数，进而释放内存资源**
- 然后智能指针是对裸指针的RAII封装，在C++的历史上一共出现过四种智能指针，分别是C++98引入的auto_ptr，C++11引入的shared_ptr、unique_ptr、weak_ptr
- 早期的 auto_ptr 和之后的 unique_ptr 是为了实现对某一堆中对象的唯一管理，但**当移交管理的时候 auto_ptr 采取的是拷贝语义，unique_ptr 采用的是移动语义**，使得后者通用性更好；shared_ptr 采取引用计数思路管理对象生命周期，当多一个指向该对象的 shared_ptr，引用计数加一，相反减一，引用计数为 0 时，释放被指向的内存空间；weak_ptr 是为了解决 shared_ptr 强指向可能出现的循环引用导致的内存泄漏，和当被指向的对象被释放产生的悬垂指针问题。使用时需要注意尽量不要直接使用智能指针的裸指针
- 要使用智能指针，需要包含头文件 memory ，然后使用通常的模板语法来实例化所需类型的智能指针，例如：

```C++
auto_ptr<double> pd(new double);
//new double是new返回的指针，指向新分配的内存块，它作为模板类auto_ptr的构造函数的实参
```

- 智能指针模板类的常用接口有：
```C++
T* get();//用于得到C++内置指针，这个操作是比较危险的，因为脱离了智能指针的管理
//永远不要使用 get 初始化另一个智能指针或为智能指针赋值，否则很容易造成两个智能指针指向同一块内存
//当两个类的对象的析构函数释放同一块内存会造成程序崩溃
T& operator*();   
T* operator->();  
T& operator=(const T& val); 
T* release();  
void reset (T* ptr = NULL);
/*
T 是模板参数, 也就是传⼊的类型；

get()⽤来获取封装在智能指针内部的指针, 也就是获取原生指针；

operator()表示操作符重载 , operator->() 重载了->, operator=() 重载了=；

release()放弃对指针的控制权，返回指针，并将u置为空；
reset()直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值, 则将内部指针初始化为该值(否则将其设置为默认参数NULL)；
*/ 
```

-  auto_ptr (C++98的方案，C++11已抛弃)采用所有权(ownership)模式

```C++
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr的互相赋值，采用拷贝语义，不报错
```

编译阶段不会报错！程序最终的结果是 p2 剥夺了 p1 对 string 对象的所有权，因为当执行  p2 = p1  的时候， p1 失去所有权、被置为 NULL ，这样可防止 p2 和 p1 的析构函数试图删除同一个对象。但是当其他程序运行时访问 p1 时会报错，因为它不再指向有效的数据，所以 auto_ptr 的缺点是：**存在潜在的内存崩溃问题(运行时)，不能指向数组，不能从函数中返回 auto_ptr，也不能作为 STL 容器的成员**

-  unique_ptr (替换 auto_ptr )

```C++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2；
pu2 = pu1; //报错，会留下悬挂的pu1，unique_ptr使用移动语义，不允许拷贝
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("you")); //不报错
```

unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该象。它对于避免资源泄漏特别有用，即 unique_ptr 比 auto_ptr 更安全。总之，程序试图将一个 unique_ptr 赋给另一个时，如果源 unique_ptr 是个临时右值(例如调用构造函数创建匿名对象)，编译器允许这样做；但如果源 unique_ptr 将存在一段时间，编译器禁止这样做。 **unique_ptr 无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值(类的实现中对拷贝构造函数和拷贝赋值运算符使用 `= delete`)**，也即可以从函数中返回 unique_ptr
- **智能指针模板类 auto_ptr 、 shared_ptr 使用 delete 而不是 delete [] ，因此只能与 new 一起使用，而不能与 new [] 一起使用，但 unique_ptr 拥有 new 搭配 delete 、 new[] 搭配 delete[] 的两个不同版本**

```C++
auto_ptr<int> pia(new int[20]); //报错，auto_ptr只能与new一起使用

int a = 6;
auto_ptr<int> pa(&a); //报错，只能指向使用new运算符开辟的内存空间(即堆内存)，而不能使用已存在变量的内存空间

string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pv(&vacation); //报错，当pv过期时，delete运算符将用于非堆内存，这是错误的
```

-  shared_ptr (共享型，强引用)： shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性( auto_ptr 是独占的)，在**使用引用计数的机制上提供了可以共享所有权**的智能指针，即多个智能指针可以指向相同对象，该对象和其相关资源会在 “最后一个引用被销毁” 时候释放。可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊ auto_ptr 、 unique_ptr 、 weak_ptr 来构造。当调用 release() 时，当前指针会释放资源所有权，引用计数减 1；仅当引用计数等于 0 时，才调用 delete ，释放内存资源
-  weak_ptr (弱引用)：如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，也就是内存资源永远不会被释放。为解决上述问题引入了 weak_ptr ，**它是一种不控制对象生命周期的智能指针**，用来解决 shared_ptr 相互引用时的死锁问题。 weak_ptr 指向一个 shared_ptr 管理的对象，但进行该对象内存管理的却只是强引用的  shared_ptr， weak_ptr 只是提供了对管理对象的**一个访问手段**。 weak_ptr 设计的目的是为配合 shared_ptr 而引⼊的一种智能指针来协助 shared_ptr ⼯作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造。**它是对对象的一种弱引用，其构造函数和析构函数不会引起引用记数的增加或减少。它和 shared_ptr 之间可以相互转化， shared_ptr 可以直接赋值给它，它可以通过调用 lock() 函数来获得 shared_ptr** 。当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（析构函数没有被调用），解决办法：把其中一个改为 weak_ptr 就可以(解决 shared_ptr 循环相互引用的问题)

```C++
#include <iostream>
#include <memory>

using namespace std;

class B; //前置声明
class A
{
    public:
        shared_ptr<B> pb_;
        ~A()
        {
            cout << "A delete" << endl;
        }
};
class B
{
    public:
        shared_ptr<A> pa_;
        ~B()
        {
            cout << "B delete" << endl;
        }
};
void fun()
{
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    pb->pa_ = pa;
    pa->pb_ = pb;
    cout << pb.use_count() << endl;
    cout << pa.use_count() << endl;
}
int main()
{
    fun();
    return 0;
}
```

- 在初始化智能指针的时候尽量使用**标准库函数 make_shared(C++11) 和 make_unique(C++14) 方法(注意它们不是模板库的成员函数)**，一来可以加快初始化智能指针的速度(少分配一次内存)，二来可以避免因赋值初始化操作执行一半造成的内存泄漏，提高了异常安全性([参考链接](https://blog.csdn.net/casic207/article/details/108122460)、https://blog.csdn.net/coolmeme/article/details/43405155?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-43405155-blog-108122460.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-43405155-blog-108122460.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=1)

```C++
shared_ptr<double> p1 = make_shared<double>(3.14);
shared_ptr<double> p2 = new double(); 
```

- **由于 auto_ptr 使用拷贝语义，有可能造成内存泄漏，所以不支持在STL容器中使用；而 unique_ptr 使用移动语义，不会造成内存泄漏，所以支持在STL容器中使用；shared_ptr、weak_ptr 也支持在STL容器中使用**
- C++八股文（一）：说一下C++中的智能指针？ - TripleRS的文章 - 知乎
https://zhuanlan.zhihu.com/p/617052742

### :rocket: **shared_ptr 如何实现引用计数?**

- shared_ptr 由两个指针构成：一是指向被管理对象的指针，用于访问该对象，get() 函数返回的是这个指针；二是指向 int 型变量的指针
- 模板类中有一个指向 int 型变量的指针，在初始化智能指针时该指针指向常量1的内存空间；在拷贝构造时会执行普通指针的拷贝；在拷贝赋值时会先释放源对象的这个指针，然后再执行普通指针的拷贝；在对象析构时会先递减此指针指向的内存空间中的值，再检查是否为零，若为零则释放指向被管理对象的内存空间。**在操作指向引用计数的指针时，会用到加锁和解锁**
- 程序实例详见20230625_SharedPtr.cpp
- 参考链接：https://blog.csdn.net/newchenxf/article/details/116019535

### :rocket: **unique_ptr 如何实现资源独占?**

- 模板类中禁用了拷贝构造函数和拷贝赋值运算符，只允许移动构造和移动拷贝，发生移动构造或移动拷贝之后，源对象将处于可析构状态，也就是指针会被释放，并显式地置为空
- 程序实例详见20230625_UniquePtr.cpp
- 参考链接：https://blog.csdn.net/newchenxf/article/details/116274506

### :rocket: **如何判断 weak_ptr 是否失效?**

- 由于 weak_ptr 不会改变资源的引用计数，因此它所指向的对象可能失效，所以不能使用 weak_ptr 直接访问对象，而必须调用其成员函数 lock()，此函数检查 weak_ptr 指向的对象是否存在。**如果存在，函数返回一个指向共享对象的 shared_ptr，也即表明所指向的对象仍然存在**

### :rocket: **为什么尽量不要使用裸指针初始化智能指针?为什么不要从智能指针中返回裸指针**

- 因为可能存在同一个裸指针初始化多个智能指针的情况，这样的话会在智能指针析构时造成同一资源的多次释放
- 从智能指针中返回的裸指针如果被释放，智能指针所指向的资源也失效了，这样的话对智能指针的操作是未被定义的行为

### :rocket: **智能指针的线程安全问题?**

- 智能指针的控制块是线程安全的，但对资源的访问和操作不是线程安全的。如果需要原子类型的智能指针，可以考虑C++20中引入的原子智能指针 std::atomic_shared_ptr 和 std::atomic_weak_ptr

### :rocket: **叙述 RAII 及其实现机制?**

- RAII 是 Resource Acquisition Is Initialization 的缩写，翻译成中文是资源获取即初始化。**在对象初始化时获取资源，在对象析构时释放资源。这种技术可以避免资源泄漏或内存泄漏，提高程序的健壮性和可维护性**
- 使用 RAII 可以管理动态分配的内存而不需要手动申请和释放、管理锁不需要手动加锁和解锁、管理句柄不需要手动打开和关闭，包括 std::shared_ptr、std::unique_ptr、std::lock_guard 和 std::unique_lock

```C++
class lock_guard
{
public:
    explicit lock_guard(std::mutex& mtx) : mtx_(mtx){ 
        mtx_.lock(); 
    }
    ~lock_guard() { mtx_.unlock(); }
    // 禁止拷贝构造和拷贝赋值，因为该类中存在不允许拷贝的成员变量
    lock_guard(const lock_guard &) = delete;
    lock_guard &operator=(const lock_guard &) = delete;
private:
    std::mutex&  mtx_;
};
```

- 注意与 RTTI(Runtime Type Identification) 相区别，RTTI是运行时类型识别，是指在程序运行期间，动态获取对象的类型信息的能力，主要使用dynamic_cast、typeid、type_info等关键字实现

### :rocket: **如果遇到内存泄漏的问题，一般怎么解决?**

- 在程序中加入必要的错误处理代码，避免程序因为异常情况而导致内存泄漏
- 使用智能指针等RAII机制，自动管理内存，避免手动管理内存的麻烦和出错风险
- 使用内存分析工具，检测程序中的内存泄漏，并进行相应的修复
- 把所有使用 malloc/free 的地方改成 new/delete，重载全局的 new 和delete，并加入申请和释放内存容量的统计逻辑
- 可以使用诸如 Valgrind(Linux) 或 Dr. Memory(Windows) 等内存调试工具来检测内存泄漏。这些工具可以在运行程序时检测内存泄漏，并提供详细的报告和调试信息

## 面向对象

### :rocket: **面向对象的三大方式?**

- 组合(composition)、委托(delegation)、继承(inheritance)、
![](../picture/复合.png)
![](../picture/复合的内存分析.png)
![](../picture/委托.png)
![](../picture/继承.png)
![](../picture/继承关系的构造与析构.png)

### :rocket: **面向对象的三大特征?**

- 封装、继承、多态，各自举例说明
- 类的接口包括用户所能执行的各种操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数，**封装实现了类的接口和实现的分离，使得类的实现细节对用户不可见，用户只能使用接口而无法访问实现部分**。此外，可以用过访问说明符加强类的封装性，public 成员在整个程序内可被访问，private 成员只能被类的成员函数和友元函数访问，private 部分封装了类的实现细节，protected 成员可以被派生类的成员函数访问
- 使用继承，可以定义相似的类型并对其相似关系进行建模，通过继承联系在一起的类构成一种层次关系，在层次关系的根部有一个基类，其他类则直接或间接从基类继承而来，这些继承而来的类称为派生类，基类负责定义在层次关系中所有类所共同拥有的成员，而每个派生类定义各自特有的成员
- 使用多态，可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。在具有继承关系的类中，基类的指针或引用可以绑定至派生类的对象，这就使得通过基类的指针或引用使用派生类对象成为可能。通过基类的引用或指针调用基类中定义的一个函数时，如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是指针或引用所绑定的对象的真实类型
- **C++融合了五种编程范型：分别是面向过程、基于对象、面向对象、泛型和函数式**

### :rocket: **声明、定义、初始化、赋值有何区别?**

- 声明是告诉编译器这里有个符号，但不分配内存
- 定义是告诉编译器，这里有个符号，并且要分配内存
- 初始化是在分配内存的时候给它一个初始值
- 赋值是将这块内存原来的值擦除，给它填入一个新值

### :rocket: **C语言与C++中 struct 有什么异同?**

- 在C语言中，struct 仅仅是一个结构体，其中只能包含数据成员
- 在C++中，struct 可以用来定义一个类，其中可以包含数据成员和函数成员，可以定义构造函数、析构函数、静态成员变量
- **在C语言中，不允许定义空 struct，其中至少要包含一个数据成员；在C++中，可以定义空 struct，其中不包含任何数据成员，但在编译时系统也会生成1字节的占位符**

### :rocket: **在C++中 class 与 struct 之间有什么异同?**

- 在C++中， class 与 struct 都可以被用来定义一个类，都可以在其中包含成员变量与成员函数，都可以定义构造函数、析构函数、静态成员变量等，**并且它们可以互相继承**，程序实例见 20230713_struct与class互相继承.cpp
- 区别在于 class 对于数据成员的默认访问权限是 private 的，而 struct 对于数据成员的默认访问权限是 public 的；**默认情况下，使用 class 关键字定义的派生类是私有 private 继承其他类的，而使用 struct 关键字定义的派生类是公有 public 继承其他类的**

```C++
class A {
    int x;
};
class B : A { // 默认是private继承
    int y;
};
struct C {
    int x;
};
struct D : C { // 默认是public继承
    int y;
};
```

- 程序实例详见 20230409_struct与class的异同.cpp

### :rocket: **class 中可能有哪些缺省函数？**

### :rocket: **一个空类在实例化对象时可能生成哪些函数？**

### :rocket: **空结构体占用多大内存？**

- 上面三道题都考察一个知识点，因此放到一起讲

```
struct Data {}; //定义空结构体/空类
```
- 在Windows下，C语言中不允许定义空结构体变量
- 在gcc Linux/Unix下，C语言中`sizeof(Data) = 0`
- 当只定义空类不实例化对象时，编译器不会生成任何的成员函数，只会生成1个字节的占位符，因此对于空类`class A {};`或`struct A {}`，`sizeof(A) = 1`。程序实例见 20230711_只定义空类不实例化对象.cpp
- 当实例化空类的对象时，编译器会生成：**一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符、两个取址运算符(const 版本与非 const 版本)**，程序实例见 20230712_实例化空类.cpp

### :rocket: **类可以包含引用类型的成员变量吗？**

- 类可以包含引用类型的成员变量，当要实例化该类的对象时有以下限制：
- 不能使用合成的默认构造函数初始化，这是因为合成的默认构造函数会按照如下规则初始化类的数据成员：如果存在类内初始值，用它来初始化成员，否则默认初始化(值初始化)该成员。**而无论是类内初始值或值初始化，合成的默认构造函数都试图将左值引用绑定到右值(字面值常量)上，这是非法的**
- 因此用户必须显式提供构造函数，且在该构造函数中的成员初始化列表中初始化引用成员变量，否则会造成引用未初始化错误，而且自定义构造函数的对应形参也必须是引用类型
- **不能在构造函数的函数体赋值(为什么不是说初始化呢？因为所有的成员变量都是在初始化列表中完成的)，必须在成员初始化列表中进行初始化**
- **注意：构造函数分为初始化和计算两个阶段，前者对应成员初始化列表，后者对应构造函数函数体。引用必须在初始化阶段，也即在成员初始化列表中完成，否则编译时会报错(引用未初始化)**
- 程序实例见 20230715_类可以包含引用类型的成员变量.cpp

### :rocket: **叙述多态，用到了哪些技术？**

- 多态分为静态/编译时多态和动态/运行时多态，前者用到了类模板与重载，后者是类继承与虚函数的重写
- 把具有继承关系的多个类型称为多态类型，**引用或指针的静态类型与动态类型不一致是C++语言支持多态性的根本所在**。当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
- **在动态多态中，基类指针或引用可以绑定至派生类的对象，永远指向的是派生类中基类部分数据的起始地址，父类的指针或引用并不能访问子类中在父类未出现的函数和变量(遵循名字查找优先规则)，只能访问虚函数表中的函数**
- **即使指针或引用的静态类型与动态类型可能不一致，但能通过指针或引用调用哪些成员仍然是由静态类型决定的，也即静态类型决定了编译器在编译时期做哪些检查，而动态类型决定了运行时期调用哪个虚函数**

### :rocket: **函数模板的底层工作原理是什么？**

### :rocket: **如何理解虚函数、虚指针(vptr)、虚函数表(vtbl)、虚函数指针？**

- 基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数，使用关键字 virtual 实现。当使用基类的指针或引用调用虚函数时，该调用会被动态绑定。根据指针或引用所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行派生类的版本
- **因此必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪一个虚函数。任何构造函数之外的非静态函数都可以是虚函数**
- C++主要使用了虚指针和虚表来实现多态。**在任何含有虚函数的类中**，不论这个虚函数是继承而来的还是自己定义的，都包含一个虚指针(virtual pointer，一般位于对象所在内存的起始位置)，这个虚指针指向一个虚函数表(virtual table)，**虚函数表本质上是一个数组，数组中的每个元素都是指向虚函数的指针**
- 如果父类的虚函数没有被子类重写，那么子类虚函数表中的元素就是父类虚函数表中对应的虚函数指针；相反，如果子类重写了父类的虚函数，那么虚函数表中对应的元素就是自己的虚函数指针，决定这个指向的过程发生在运行时，即所谓的动态绑定

- 单继承程序实例与内存分析
```C++
#include <iostream>

struct Foo
{
    size_t a = 42;
    virtual void fun1() {std::cout << "Foo::fun1" << std::endl;}
    virtual void fun2() {std::cout << "Foo::fun2" << std::endl;}
    virtual void fun3() {std::cout << "Foo::fun3" << std::endl;}
};

struct Goo : Foo
{ //使用struct关键字定义的派生类默认是public继承
    size_t b = 1024;
    virtual void fun1() override {std::cout << "Goo::fun1" << std::endl;}
    virtual void fun3() override {std::cout << "Goo::fun3" << std::endl;}
};

using PF = void(*)(); //声明函数指针类型

void test(Foo* pf)
{
    size_t* virtual_pointer = (size_t*)pf;
    // 将基类的指针强制转化为指向size_t类型的指针

    PF* pf1 = (PF*)*virtual_pointer;
    PF* pf2 = pf1 + 1;  //偏移8字节 到下一个函数指针 fun2
    PF* pf3 = pf1 + 2;  //偏移16字节 到下下一个函数指针 fun3

    (*pf1)();   //Foo::fun1 or Goo::fun1 取决于pf1的真实类型
    (*pf2)();   //Foo::fun2
    (*pf3)();   //Foo::fun3 or Goo::fun3 取决于pf2的真实类型
}

int main(int argc, char const *argv[])
{
    Foo* fp = new Foo; //定义指向基类对象的指针
    test(fp);

    fp = new Goo; //基类的指针可以指向派生类的对象
    test(fp);

    size_t* virtual_pointer = (size_t*)fp; 
    size_t* ap = virtual_pointer + 1;
    size_t* bp = virtual_pointer + 2;

    std::cout << *ap << std::endl;  //42
    std::cout << *bp << std::endl;  //1024
}
```

![](../picture/单继承时的虚指针与虚表.png)
- 右上图中的函数应该依次为Foo::fun1、Foo::fun2、Foo::fun3

- 当初始化虚表时，会把当前类 override 的函数地址写到虚表中(Goo::fun1、Goo::fun3)，对于基类中的虚函数但是派生类中没有override，则会把基类的函数地址写到虚表中(Foo::fun2)，**在调用函数的时候，会通过虚指针转到虚表，并根据虚函数的偏移得到真实函数地址，从而实现多态**

- 多继承程序实例与内存分析
```C++
#include <iostream>
struct Foo1
{
    size_t a = 42;
    virtual void fun1() {std::cout << "Foo1::fun1" << std::endl;}
    virtual void fun2() {std::cout << "Foo1::fun2" << std::endl;}
    virtual void fun3() {std::cout << "Foo1::fun3" << std::endl;}
};

struct Foo2
{
    size_t b = 1024;
    virtual void fun4()  {std::cout << "Foo2::fun4" << std::endl;}
    virtual void fun5()  {std::cout << "Foo2::fun5" << std::endl;}
};

struct Foo3
{
    size_t c = 0;
    virtual void fun6()  {std::cout << "Foo3::fun1" << std::endl;}
    virtual void fun7()  {std::cout << "Foo3::fun3" << std::endl;}
};

struct Goo: public Foo1, public Foo2, public Foo3
{
    virtual void fun2() override {std::cout << "Goo::fun2" << std::endl;}
    virtual void fun6() override {std::cout << "Goo::fun6" << std::endl;}
};

int main(int argc, char const *argv[])
{
    Goo g;
    g.fun1();   //Foo1::fun1
    g.fun2();   //Goo::fun2
    g.fun3();   //Foo1::fun3
    g.fun4();   //Foo2::fun4
    g.fun5();   //Foo2::fun5
    g.fun6();   //Goo::fun6
    g.fun7();   //Foo3::fun7
}
```

![](../picture/多继承时的虚指针与虚表.png)
- 上图左侧Goo对象中的内存布局顺序应该是：vptr1->a->vptr2->b->vptr3->c

### :rocket: **空类是否具有虚函数指针？**

- 空类不具有虚函数指针，只会生成一个字节的占位符

### :rocket: **什么是菱形继承？会引发什么问题？如何解决？**

- 菱形继承(Diamond Inheritance)是指在继承层次结构中，如果两个不同的子类B和C继承自同一个父类A，而又有一个类D同时继承B和C，这种继承关系被称为菱形继承

![](../picture/菱形继承.png)
```C++
#include <iostream>

struct A
{
    int val = 42;
    virtual void fun(){std::cout << "A::fun" << std::endl;}
};
struct B : public A
{ 
    void fun() override {std::cout << "B::fun" << std::endl;}
};
struct C : public A
{ 
    void fun() override {std::cout << "C::fun" << std::endl;}
};
struct D : public B, public C
{
    void fun() override {std::cout << "D::fun" << std::endl;}
};

int main(int argc, char const *argv[])
{
    D d;
    std::cout << d.val << std::endl; //编译失败，不知道调用从哪个类中继承的val变量
    d.fun();

    return 0;
}
```
- 解决方法一是在使用成员前加上作用域解析运算符，明确指出使用哪个类中的成员，例如`std::cout << d.B::val << std::endl;`，`d.B::fun();`；但这里并没有解决数据冗余的问题，因为D中有B和C，而B和C各有一个虚表和一个int类型的成员变量，所以sizeof(D)的大小是32(x86_64架构，考虑到内存对齐)
- 解决方法二是使用C++11引入的虚继承机制。虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中这个**被共享的基类就称为虚基类**，本例中的 A 就是一个虚基类。**在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员**

```C++
#include <iostream>

struct A
{
    int val = 42;
    virtual void fun(){std::cout << "A::fun" << std::endl;}
};
struct B : virtual public A
{ 
    void fun() override {std::cout << "B::fun" << std::endl;}
};
struct C : virtual public A
{ 
    void fun() override {std::cout << "C::fun" << std::endl;}
};
struct D: public B, public C
{
    void fun() override {std::cout <<"D::fun" << std::endl;}
};

int main(int argc, char const *argv[])
{
    D d;
    std::cout << d.val << std::endl; //42
    d.fun();     //D::fun
}
```
- 此时在对象d中，只包含了一个 val 和两个虚指针，成员变量的冗余问题得到解决

### :rocket: **单/多重继承中类对象的虚表和成员变量在内存中如何分布？**

- **类的继承分为成员变量的内存继承和成员函数的调用权(而不是内存)继承**

- 单继承内存分布图如下：
![](../picture/类继承时的内存分布.jpg)

- 子类的对象之中含有父类的成分
- 多重继承中，每个类都有自己的虚表，派生类对象中的虚指针指向的是派生类的虚表，**派生类对象中的成员变量按照继承顺序依次排列**

- **动态绑定发生的前提条件：基类的指针(可以指向派生类对象)调用虚函数**

### :rocket: **一般认为多态会影响性能？为什么？**

- 大多数人认为，虚函数的调用会先通过虚指针跳到虚函数表，然后通过偏移确定函数真实地址，再跳转到地址执行，是间接调用导致了性能损失
- 但实际上无法内联才是虚函数性能低于正常函数的主要原因。**由于多态是运行时特征，在编译时编译器并不知道指针指向的函数地址，所以无法被内联**。同时跳转到特定地址执行函数可能引发的L1 cache miss(空间局部性不好)，这也会影响性能
- 现代编译器很聪明，如果编译器能够在编译时推断出真实的函数，可能会直接内联这个虚函数。虚函数的调用是否内联取决于编译器的实现和上下文

### :rocket: **多态会不会造成安全性问题？**

- 当把类中的虚函数定义为 private 的时候，虽然不能通过类的对象去访问这个函数，但已经知道这个函数就在虚函数表中，可以通过特殊的方法(上文中已经给出示例)访问它

```C++
#include <iostream>

struct Foo
{
    private:
        virtual void fun() 
        { std::cout << "Foo::fun" << std::endl;}
};

int main(int argc, char const *argv[])
{
    Foo f;
    // f.fun();  //编译错误
    using Fun = void(*)();
    size_t* virtual_point = (size_t*)&f;
    Fun* fun = (Fun*)*virtual_point;
    (*fun)();
}
```

### :rocket: **非虚函数、纯虚函数与虚函数有何异同？**

- 不希望子类重写/覆盖的函数定义为非虚函数；希望子类重写/覆盖且已提供定义的函数定义为虚函数；希望子类重写/覆盖但并未提供定义的函数定义为纯虚函数
- 纯虚函数与虚函数的区别在声明形式上为：`virtual 函数类型 函数名 (参数列表) = 0;`，其中`= 0`是纯虚函数的标志，它告诉编译系统，该函数没有函数体，不能被调用，但要求派生类必须定义自己的版本
- **虚函数必须有定义**，且定义在类的内部或外部均可；**而纯虚函数可以没有定义，因为纯虚函数本身是没有实际意义的**，当要定义纯虚函数时，必须在类外部定义，且不能带有声明纯虚函数时的`= 0`
- 含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类，抽象基类负责定义接口，而由派生类负责实现接口，**不能定义抽象基类的对象，但可以定义抽象基类的指针或引用，通过它们可以访问派生类的对象**

### :rocket: **叙述三种继承方式的经典应用场景？**

- C++ Primer P542 15.5 访问控制与继承

### :rocket: **析构函数可以是虚函数吗？为什么？构造函数呢？**

- 析构函数一般情况下都是虚函数。在继承关系的类中通常应该为基类定义虚析构函数。这是因为当 delete 一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况，只有在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本
- 如果一个类定义了析构函数，即使它通过`= default`的形式使用了合成的版本，编译器也不会为这个类合成移动操作
- 构造函数不能是虚函数，因为此时虚表虽然已在编译阶段建立，但在构造对象时虚函数指针还未被初始化，所以无法调用虚函数

### :rocket: **构造函数可以调用虚函数吗？**
- 构造函数不可以调用虚函数，因为在构造函数执行其函数体时，对象的类型还不确定，因此无法根据对象的类型来调用相应的构造函数

### :rocket: **构造函数可以使用关键字virtual、const、constexpr吗？**

- 构造函数不可以使用关键字 virtual，即构造函数不能是虚函数。因为此时虚表虽然已在编译阶段建立，但在构造对象时虚函数指针还未被初始化，所以无法调用虚函数
- 构造函数不可以使用关键字 const。因此构造函数需要初始化成员变量，这与 const 修饰成员函数的意义相悖。当创建一个类的 const 对象时，直到构造函数完成初始化，对象才能真正取得其“常量”属性。因此构造函数在 const 对象的构造过程中可以向其写值
- 字面值常量类的构造函数可以使用关键字 constexpr，constexpr 构造函数可以声明成`= default`形式，可以声明成`= delete`形式。否则，该构造函数就必须既满足构造函数的要求(意味着不能包含返回语句)，又满足 constexpr 函数的要求(意味着它所能拥有的唯一可执行语句就是返回语句)。**综合以上两点来看，constexpr 构造函数的函数体一般来说是空的**

### :rocket: **构造函数可以定义为私有的吗？**

- 可以将构造函数定义为私有的，这种情况下一般不希望直接通过类型定义对象，而是希望通过类的静态成员函数来创建对象，这样可以控制对象的创建，**例如单例模式**

```C++
class Singleton
{
    public:
        static Singleton& Instance()
        {
            static Singleton instance; //只有当调用Instance()时才会创建对象，且永远只有一个
            return instance;
        }
        Singleton(const Singleton&) = delete;
        Singleton(Singleton&&) = delete;
        Singleton& operator=(const Singleton&) = delete;
        Singleton& operator=(Singleton&&) = delete;
    private:
        Singleton() = default;
        ~Singleton() = default;
};

Singleton s; //编译失败
Singleton& s = Singleton::Instance();    //编译成功
```

### :rocket: **叙述四大强制类型转换？**

- C++ 中提供了四种强制类型转换，分别是 dynamic_cast、const_cast、 static_cast 和 reinterpret_cast，它们的用法如下：

```C++
dynamic_cast<type-name>(expression)
const_cast<type-name>(expression)
static_cast<type-name>(expression)
reinterpret_cast<type-name>(expression)
```

- dynamic_cast 用于将基类的指针或引用安全地转换成派生类的指针或引用，当基类的指针或引用绑定至派生类对象时转换成功，否则转换失败，返回 nullptr
- const_cast 使作用对象在类型改变前后只有 const 和 volatile 属性发生变化，也就是不能用于改变对象的类型
- static_cast 用于类层次结构中**基类和派生类之间指针或引用的相互转换**，注意与 dynamic_cast 相区别
- reinterpret_cast 用于进行各种不同类型的指针之间的转换，以及指针与足够大的整数类型之间的转换，例如可以将指针类型转换为足以存储指针表示的整型，但不能将指针转换为更小的整型或浮点型，具体实现依赖于硬件

```C++
// High 和 Low 是两个类，ph 和 pl 的类型分别为High* 和 Low*
// 当 Low 是 High 的可访问基类时，下列语句是合法的：
High bar;
Low blow;
const High *pbar = &bar;

Low *pl = dynamic_cast<Low *>(&bar); //向上转换

High *pb = const_cast<High *>(pbar); //去掉const属性

High *ph = static_cast<High *>(&blow); //向下转换
Low *pl = static_cast<Low *>(&bar); //向上转换
```

### :rocket: **叙述C++中的类型转换？**

- 四大强制类型转换运算符
- 内置类型之间的转换
- 关键字 explicit 用于修饰转换构造函数，可以防止隐式转换
- **重载类型转换运算符，可用于将类类型转换为普通内置类型或其他类类型**

### :rocket: **函数重载、重写/覆盖与隐藏之间有何区别？**

- 函数的重载分为普通函数重载、类的成员函数重载，在同一作用域中的两个函数的名称相同而参数列表不同(参数个数、参数类型)不同时可构成重载，但只有返回类型不同无法构成重载
- 函数的重写/覆盖指的是在具有继承关系的类中，派生类中定义的虚函数如果与基类中定义的同名虚函数有相同的形参列表，则派生类版本将覆盖基类的版本，此时基类的指针或引用调用虚函数时，将根据指针或引用所绑定的对象的真实类型来决定执行哪个版本的虚函数
- 函数的隐藏指的是在具有继承关系的类中，如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名，则派生类将在其作用域内隐藏该基类成员。**即使派生类成员和基类成员的形参列表不一致，基类成员也依然会被隐藏掉(遵循名字查找优先规则)。为了避免上述现象的发生，除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字**
- 隐藏不等于没有继承，还是可以用过作用域运算符来强制调用基类的成员函数

### :rocket: **继承虚函数需要写 virtual 吗？override 呢？**

- 在派生类中覆盖某个虚函数时，可以使用 virtual，也可以不使用 virtual，**这是因为一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数**
- 在派生类中覆盖某个虚函数时，可以使用 override，也可以不使用 override，**但在C++ 11之后最好使用该关键字**，它将帮助我们避免编程错误。如果使用 override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将会报错

### :rocket: **虚函数重载、模板重载与普通函数重载有何区别？**

### :rocket: **什么是函数模板？什么是类模板？二者有何区别**

- 函数模板是可以实例化出特定函数的模板，类模板是可以实例化出特定类的模板
- 从形式上来说，函数模板与普通函数类似，只要是以关键字 template 开始，后接**模板参数列表**，再接函数声明或定义的函数，就是函数模板。类模板与普通类类似，只要是以关键字 template 开始，后接模板参数列表，再接类声明或定义的类，就是类模板
- **从使用上来说，编译器会根据用户的调用实参来推断函数模板的模板参数类型，而使用类模板想要实例化特定类时就必须指定模板参数**

### :rocket: **为什么模板类要写在 .h文件中，而不写在 .cpp文件中？**

- 参考链接：https://zhuanlan.zhihu.com/p/147623943
- 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件既包括声明也包括定义

## STL(Standard Template Library)

### :rocket: **STL的六大部件有哪些，之间有何联系？**
- STL的六大部件分别是容器(container)、算法(algorithm)、迭代器(iterator)、仿函数(functor)、适配器(adapter)和空间分配器(allocator)
- 顺序容器：vector、deque、list、forward_list、array、string，其中 forward_list 和 array 是 C++11 新增的，string 是基于 char* 类型的特殊容器
- 适配器是一种机制，能使某种事物的行为看起来像另一种事物。一个容器适配器则接受一种已有的容器类型，使其行为看起来像一种不同的类型。**STL 提供了三种顺序容器适配器：stack、queue 和 priority_queue，默认情况下，stack 和 queue 是基于 deque 实现的，priority_queue 是基于 vector 实现的**。可以在创建一个适配器时，将一个命名的顺序容器作为第二个类型参数，来重载默认的容器类型
```C++
// 在vector上实现的空栈
stack<string, vector<string>> str_stk;

// str_stk2在vector上实现，初始保存svec的拷贝
stack<string, vector<string>> str_stk2(svec);
```
- 关联容器可以分为两大类，其中按关键字有序保存元素的关联容器有：set、multiset、map、multimap，C++11又新增了无序关联容器，包括：unordered_set、unordered_multiset、unordered_map、unordered_multimap
- 迭代器可分为输入迭代器(input iterator)、输出迭代器(output iterator)、前向迭代器(forward iterator)、双向迭代器(bidirectional iterator)、随机访问迭代器(random access iterator)，其中输入迭代器和输出迭代器分别用于读取和写入数据，前向迭代器只能向前访问而不能向后访问(forward_list)，双向迭代器既可向前又可向后(list)，而随机访问迭代器可以通过下标访问任何合法位置(vector)
- **仿函数又称为函数符或函数对象或可调用对象，包括函数、函数指针、lambda表达式、使用库函数 bind() 创建的对象、重载了函数调用运算符 operator() 的类**
- 分配器主要用于内存的分配与释放。一般容器都会自带默认分配器，很少会自己实现分配器。分配器的具体实现如下：
```C++
template <typename T>
class MyAllocator {
public:
    typedef T value_type;
    MyAllocator() noexcept {}
    template <typename U>
    MyAllocator(const MyAllocator<U>& ) noexcept {}

    T* allocate(std::size_t n) {
        if (n > std::size_t(-1) / sizeof(T)) throw std::bad_alloc();
        if (auto p = static_cast<T*>(std::malloc(n * sizeof(T)))) return p;
        throw std::bad_alloc();
    }

    void deallocate(T* p, std::size_t) noexcept {
        std::free(p);
    }
};
```
- 算法主要分为查找、排序和数值操作三大类。查找包括有：find、find_if、find_first_of，排序包括有sort、stable_sort、partial_sort，数值操作包括有accumulate、fill、fill_n、transform
- **六大部件之间的联系有：空间分配器为容器分配管理内存；处理容器的算法独立于数据类型和容器类型之上，为使通用算法适用于具体情况，每个算法都会对它的每个迭代器参数指明须提供哪类迭代器，而每个容器都有自己的迭代器类型，即迭代器是容器与算法的桥梁；仿函数一般用在算法中，用于指定算法的操作；适配器提供类似黏合剂的功能，把各种不同部件之间的接口连接起来**

### :rocket: **已经有了指针，为何还需要引入迭代器?**

- 泛型编程要求算法不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。其中**模板提供了存储在容器中的数据类型的通用表示，而迭代器则提供了对容器中元素的通用访问方式**
- 从迭代器的实现功能来看，内置类型的指针可以满足迭代器的大部分操作
- 在STL中，每个容器类都定义了相应的迭代器类型，对其中一些类而言，迭代器可能是指针，而对另外一些类而言，则可能是对象，不管实现方式如何，迭代器都将提供所需的操作
- 每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个位置之后，这个值将被赋给迭代器。每个容器类都有 begin() 和 end() 方法，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器

### :rocket: **叙述可能使得迭代器失效的情况?**

当向容器中插入元素时：
- 如果容器是 vector 或 string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效；如果存储空间未被重新分配，指向插入位置之前的元素的迭代器、指针、引用仍有效，但指向插入位置之后元素的迭代器、指针和引用都将失效
- 对于 deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效；如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
- 对于 list 和 forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针、引用仍然有效

当删除容器中的一个元素后：
- 对于 list 和 forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针、引用仍然有效
- 对于 deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外的其他元素的迭代器、指针和引用都会失效；如果是删除 deque 的尾元素，则尾后迭代器也会失效，但其他迭代器、指针、引用不受影响；如果是删除首元素，迭代器会失效，指针和引用也不会受影响
- 对于 vector 和 string，指向被删元素之前元素的迭代器、引用和指针仍有效。**当删除元素时，尾后迭代器总是会失效**
- **注意：当添加/删除 vector 或 string 的元素之后，或在 deque 中首元素之外的任何位置添加、删除元素后，原来 end 返回的迭代器总是会失效。因此循环程序必须反复调用 end，而不能在循环之前保存 end 返回的迭代器**

### :rocket: **vector 与 list 的底层实现、应用场景有何异同？**

- vector 将元素保存在连续的内存空间中，因此其最大优点是支持随机访问。但是在容器的中间位置添加或删除元素将非常耗时，在一次添加或删除操作之后，需要移动添加/删除位置之后的所有元素以保持连续存储。而且有时会造成内存的重新分配，这种情况下每个元素都需要移动到新的存储空间中
- list 的优点是容器任何位置的添加或删除操作都很快速，相应的缺点是不支持元素的随机访问，为了访问一个元素在最坏情况下需要遍历整个容器，而且相比 vector 其内存空间开销也很大
- 因此根据使用场景中的操作来选择使用哪种容器。如果使用场景中需要频繁地向容器中添加或删除元素就使用 list，如果使用场景中需要随机访问容器中的元素就用 vector

### :rocket: **vector 的底层实现机制？**

- https://blog.csdn.net/qq_50408340/article/details/121461494
- https://blog.csdn.net/aruewds/article/details/117375364
- vector 中实际上有三个指针，分别指向容器的首元素、尾元素的下一个位置和容器的尾后位置
![](../picture/vector实现机制.png)

### :rocket: **叙述 vector 的扩容原理，扩容因子是如何选择的？**

- vector 是顺序容器，**底层使用动态数组来存储对象**，为了支持快速随机访问，其内存是连续的。调用成员函数 capacity() 可查看容器当前的最大容量，调用成员函数 size() 可查看当前容器中的元素个数，当有效元素个数与容器容量相等时会触发扩容机制，即程序会向系统重新申请一块更大的内存，将原有数据拷贝到新的内存中，然后释放原有内存。如果容器中存放的是类的对象，那么在这个过程中会调用拷贝构造函数/移动构造函数(noexcept)和析构函数
- 如果预知需要插入的数据量，可以调用成员函数 reverse() 来预分配内存，`reverse(n)`至少会分配容纳 n 个元素的内存空间
- 等长扩容方式(即每次扩容时增加的内存空间的长度固定)的平均时间复杂度为O(n)，倍数扩容方式(即每次扩容后的内存空间长度均为原内存空间的倍数)的平均时间复杂度为O(1)，但是倍数扩容方式会浪费一些内存空间
- 使用2倍扩容机制扩容时，每次扩容后 capacity 的情况为“ 1 2 4 8 16 ”，每次扩容后的需要开辟新内存大小必定大于前面的总和，也就意味着之前释放的内存空间永远无法被下一次的扩容利用；而使用1.5倍扩容时，每次扩容后 capacity 的情况为“ 1 2 3 4 6 9 13 19 28(向下取整) ”，在几次扩容以后，可以重用之前的内存空间，这显然对内存和 cache 要友好的多。**综上，2倍扩容方式时间上占优，1.5倍扩容方式空间上占优**
- 在扩容过程中，不同的操作系统会选择不同的扩容因子，比如 Windows 选择1.5倍，Linux 选择2倍。**这是由于 Windows 中堆管理系统会对释放的堆块进行合并**，因此 vector 扩容机制选择使用1.5倍的方式扩容，这样多次扩容之后，就可以使用之前已经释放的空间
- 如果希望有某一种倍数扩容方式，在时间和空间上都达到最优，那么每次扩容后capacity 的情况应该为“ 1 2 3 5 8 13 21 34 55 ”，这就是裴波那契数列，当 n 均于无穷大时，最佳的扩容因子为1.618，这也就是Mac OS的扩容因子选择为1.6倍的原因([参考链接](https://blog.csdn.net/qq_44918090/article/details/120583540))


### :rocket: **vector模板库中，push_back 与 emplace_back 有何异同？**

- 两者都可以用于向顺序容器vector的尾部添加元素，过程中都有可能造成内存的重新分配
- **push_back 实际上放入容器中的是对象值的一个拷贝，而不是对象本身**，对于类类型的对象则会调用拷贝构造函数/移动构造函数(noexcept)，而 emplace_back 会将参数传递给对应的构造函数，在容器末尾直接构造元素对象

### :rocket: **vector模板库中，叙述成员函数resize、reverse的作用机制？**

- 成员函数 resize() 可以用来增大或缩小容器，对应成员函数 size()，可以获知当前容器中有效元素的数量。**如果当前大小大于所要求的大小，则容器后部的元素会被删除；如果当前大小小于所要求的大小，则会将新元素添加到容器后部**。如果容器保存的是类类型元素，且需要向容器后部添加新元素时，必须提供初始值，或元素类型必须提供默认构造函数
- 成员函数 reverse() 并不改变容器中元素的数量，它仅影响 vector 预先分配的内存空间，对应成员函数 capacity()，可以获知不重新分配内存空间的话容器可以保存多少元素。当需求大小小于当前容量时，容器不会回退内存空间；当需求大小大于当前容量时，会重新开辟内存空间并将原来的元素拷贝或移动到新内存空间中。因此，在调用 reverse() 之后，capacity() 将会大于或等于传递给 reverse() 的参数

### :rocket: **如何快速的清空vector容器并释放vector容器所占用的内存？**

- 第一种方法：使用 clear() 函数清空所有元素(这一步也能看出来该函数并不释放内存)，如果容器中存储的是类类型的对象会调用该类的析构函数，然后使用 shrink_to_fit() 函数把 capacity 和 size(0) 对齐，达到释放内存的作用：

```C++
#include <iostream>
#include <vector>
int main(int argc, char const *argv[])
{
    std::vector<int> vi;
    vi.reserve(1024);
    for (int i = 0; i < 1024; i++) vi.push_back(i);
    std::cout << vi.size() << " " << vi.capacity() << std::endl;    //1024 1024
    vi.clear(); 
    std::cout << vi.size() << " " << vi.capacity() << std::endl;    //0 1024
    vi.shrink_to_fit(); 
    std::cout << vi.size() << " " << vi.capacity() << std::endl;    //0 0
}
```

- 第二种方法：调用临时量对象的成员函数 swap() 与现存 vector 进行交换，临时量会立即析构，达到释放内存的作用：

```C++
#include <iostream>
#include <vector>
int main(int argc, char const *argv[])
{
    std::vector<int> vi;
    vi.reserve(1024);
    for (int i = 0; i < 1024; i++) vi.push_back(i);
    std::cout << vi.size() << " " << vi.capacity() << std::endl;    //1024 1024
    std::vector<int>().swap(vi); //使用临时量（size =0, capacity=0）和vi交换，临时量会立即析构
    std::cout << vi.size() << " " << vi.capacity() << std::endl;    //0 0
}
```

- **注意：使用 resize() 函数与 clear() 函数一样，只清空容器并不能释放内存，因为 resize() 函数只是改变了容器中有效元素的数量，而不会改变容器的 capacity**

### :rocket: **vector< bool> 是如何实现的？**

- vector< bool> 的实现和其他容器的实现不一致。每个元素被当作一个位而不是一个字节存储，这导致不能直接访问该元素，也无法对每个元素取地址(8个元素可能在同一个字节中存储)。所以不建议使用 vector< bool> ，必要时可以使用 std::bitset 替代

### :rocket: **栈与队列有什么区别？队列与优先队列有什么区别？**

- 栈的特点是先进后出，队列的特点是先进先出
- 队列对于其中的元素不会执行优先级排序，而**优先队列会执行默认优先级排序或自定义优先级排序**

### :rocket: **deque 实现原理、底层结构是什么？**

- 双向索引

### :rocket: **map 与 unordered_map 有何异同？**

- map 与 unordered_map 都是关联容器，都是以键值对的形式存储数据，都支持快速查找，**其中的`key`值均唯一，`value`值可以重复**
- map 是有序关联容器，包含在头文件 map 中，**底层实现是红黑树**。由于红黑树的特性，使得 map 的查找、插入、删除操作的时间复杂度均为O(logn)，适用于有序存储和快速查找的场景
- 而 unordered_map 是C++11引入的无序关联容器，**底层实现是哈希表**。由于哈希表的特性，使得 unordered_map 的查找、插入、删除操作的平均时间复杂度为O(1)，**缺点是会占用更多的内存空间**，适用于需要快速插入和查找的场景
- **注意上面说的是平均时间复杂度，因为哈希表可能会发生哈希冲突问题，即不同的键值对可能会映射到同一个哈希桶中，在最坏情况下，哈希表的查找、插入、删除操作的时间复杂度就会退化为O(n)，大于 map/红黑树的O(logn)**
- 因为 unordered_map 的底层实现是哈希表，因此在使用自定义数据类型作为`key`的时候，需要重载`==`运算符和`hash`函数，以保证哈希表的正确性，程序实例见 20230718_自定义数据类型作为unordered_set的key.cpp

### :rocket: **map 与 set 有何异同？**

- map 与 set 都是有序关联容器，底层都使用红黑树存储数据。由于红黑树的特性，使得 map 的查找、插入、删除操作的时间复杂度均为O(logn)，适用于有序存储和快速查找的场景
- map 是以键值对的形式存储数据，**其中的`key`值均唯一，`value`值可以重复**；**而 set 中认为`key`与`value`相等，且`key`值唯一；一般用于去重和自动排序的场景**
- 因为 map 与 set 都是有序关联容器，所以对于其中的`key`要进行排序。对于自定义数据类型作为`key`，要重载`<`运算符或者类外写比较器(仿函数、Lambda表达式、重载了函数调用运算符 () 的类)，以保证排序的正确性，程序实例见 20230719_自定义数据类型作为set的key.cpp

### :rocket: **priority_queue 与二叉排序/搜索树有何异同？**

- **内存占用**：二叉排序树占用的内存空间比存储的数据要多，需要分配额外的内存来存储指针指向其左右子节点；而 priority_queue 是一个容器适配器，其底层实现结构是 vector，根据数组具有下标这一特性来寻找左/右子节点
- **节点顺序**：在二叉排序树中，左子节点必须比父节点小，右子节点必须比父节点大；在堆中并非如此，以小根堆为例，其中任一节点的两个子节点都必须比父节点大，但**左右子节点的数据大小是不确定的**
- **搜索性能**：二叉排序树是为了实现动态查找而设计的数据结构，它是面向查找操作的，在二叉排序树中查找一个节点的平均时间复杂度是O(logn)；在堆中搜索并不是第一优先级，**堆是为了实现排序而实现的一种数据结构**，它不是面向查找操作的，因此在堆中查找一个节点需要进行遍历，其平均时间复杂度是O(n)

### :rocket: **unordered_map 实现原理、底层结构是什么？**

### :rocket: **unordered_map 发生哈希冲突时有哪些解决方案？**

- unordered_map 的底层数据结构实现是哈希表，哈希表的主要功能是将一个较大的范围中稀疏分布的数值映射到一个较小范围中密集分布的数值，这个映射函数称为哈希函数。哈希函数的设计是哈希表的核心，它的好坏直接影响到哈希表的性能
- 在哈希映射的过程中，可能会产生哈希冲突，主要有两种解决方式：拉链法开放寻址法
- 拉链法：在大小为待映射元素数量的哈希数组的每一个位置上都开一个单链表，哈希值相同的元素都放在相同槽位的链表上，这样就不会产生哈希冲突。但是这种方法会占用更多的内存空间，而且在查找元素时需要遍历链表，效率较低，最坏情况下时间复杂度为O(n)
![](../picture/拉链法.png)

```C++
void insert(int x) {
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++;
}

bool find(int x) {
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i]) {
        if (e[i] == x) return true;
    }
    return false;
}
```

- 开放寻址法：一般要开一个比拉链法中的哈希数组大2~3倍的数组，对于哈希值相同的元素，从哈希值在哈希数组中对应的位置一直向后寻找，直到找到待映射元素应该在哈希数组中存储的位置
![](../picture/开放寻址法.png)

```C++
int find(int x) {
    int k = (x % N + N) % N;
    while (h[k] != null && h[k] != x) {
    // 因为预先开辟的数组大小是2倍于哈希数组的大小，所以这个循环一定会终止
        k ++;
        if (k == N) k = 0;
    }
    return k; 
}
```

### :rocket: **拉链法可能会被退化成O(n)的查找效率，如何优化？**

- 参考Java中HashMap的实现原理，如果链表的长度超过一定值，会将链表转换为红黑树，这样查找的时间复杂度就会降低为O(logn)
- HashMap的实现原理 - 天青色的文章 - 知乎 https://zhuanlan.zhihu.com/p/114184134

### :rocket: **已知有下列结构体，若将其作为容器 set 的元素，还需要做什么？**

```C++
struct Point
{
    double x;
    double y;
    double z;
};
```
- 由于容器 set 不允许其中的元素重复且内部有序，因此需要重载 < 运算符
- 这类问题可以推广到任意容器中要存储自定义数据类型该如何做

### :rocket: **自定义的数据类型如何在容器/容器适配器中使用？**

- 回答这个问题需要根据具体容器/容器适配器的性质出发
- 由于 map/set/multimap/multiset 是有序关联容器，priority_queue 要实现其中元素的排序，因此当自定义数据类型作为 key 类型用在这五类容器/容器适配器中，且**需要进行关键字排序时最关键的是要在该类型内重载 < 运算符**，其他重载的运算符都是基于该运算符的。言外之意是，当自定义数据类型用作 map 的 value 值时，不需要重载 < 运算符
- **另外，对于容器中是否出现重复元素的判断还需要重载 == 运算符**
- 由于 unordered_map/unordered_set/unordered_multimap/unordered_multiset 是无序关联容器，因此当自定义数据类型作为 key 类型用在该容器中，且**需要进行判重时要在该类型内重载 == 运算符和 hash 函数**。言外之意是，当自定义数据类型用作 value 类型时，不需要重载 == 运算符和 hash 函数
- **第二种方法是在实例化容器/容器适配器类对象时传入类外写的比较器或者仿函数(lambda表达式类型、函数指针类型、重载了函数调用运算符 () 的类)作为第二个模板参数，即第二个模板参数必须是一个类类型**

### :rocket: **sort() 函数内部实现的原理是什么？**

- sort() 函数内部使用快速排序算法实现，它的时间复杂度为O(nlogn)，是一种非常高效的排序算法
- 快排的基本原理是：选择一个基准元素；将小于等于基准元素的元素移动到数组左边，大于基准元素的元素移动到数组右边，这个过程称为划分；递归地对划分后的左右两个子序列进行排序(二叉树的先序遍历)
- 当然还有一些其他优化：当排序的元素个数小于一定阈值时，使用插入排序算法；当出现大量重复元素时，使用三向划分快速排序算法

# 操作系统

### :rocket: **Linux命令相关**

- `ls`：列出当前所在目录下的文件和目录；`ls -a`：列出当前所在目录下的所有文件和目录，包括隐藏文件；`ls -l/ll`：列出当前所在目录下的文件和目录的详细信息；`ls -al`：列出当前所在目录下的所有文件和目录的详细信息，包括隐藏文件
- `cd`：切换目录；`cd ~`：切换到当前用户的家目录；`cd ..`：切换到上一级目录；`cd -`：切换到上一次所在的目录，即回退到上一次所在的目录
- `pwd`：显示当前所在的目录
- `cat`：查看文件内容；`cat -n`：查看文件内容并显示行号；`head`：查看文件的前10行；`tail`：查看文件的后10行
- `where`：查看应用程序的位置，`file`：查看文件的属性
- `echo`：打印内容到终端；`echo $PATH`：查看环境变量
- `mv`：移动文件，`cp`：复制文件，`rm`：删除文件，`mkdir`：创建目录，`rmdir`：删除目录

### :rocket: **Git命令相关**

### :rocket: **Shell命令相关**

- Shell 文件的扩展名为`.sh`，**Shell 脚本的第一行一般是`#!/bin/bash`，表示该脚本使用 bash 来解释执行**，也可以使用其他 Shell 解释执行
- 使用关键字`readonly`或`declare`，可以将变量声明为只读
- `echo`命令用于输出内容，使用变量时要使用引用符号`$`或`${}`，如`echo $name`或`echo ${name}`
- 测试参数：`-e`：判断文件是否存在，`-d`：判断是否为目录(dictionary)，`-f`：判断是否为文件(file)，`-r`：判断是否可读(read)，`-w`：判断是否可写(write)，`-x`：判断是否可执行(executable)，`-s`：判断文件是否为空
- 测试参数：`-eq`：等于(equal)，`-ne`：不等于(not equal)，`-gt`：大于(greater than)，`-lt`：小于(less than)，`-ge`：大于等于(greater equal)，`-le`：小于等于(less equal)
- `if…then…fi`：单层 if 语句，`if…then…else…fi`：单层 if-else 语句，`if…then…elif…then…else…fi`：多层 if-else 语句
- `for…in…do…done`：循环语句，`for((…;…;…)) do…done`：范围循环语句


### :rocket: **进程与线程有何区别？**

- 进程是资源调度的基本单位，**运行一个可执行程序会创建一个或多个进程**，进程就是运行起来的可执行程序(程序是动态的)
- 线程是程序执行的基本单位，**每个进程中有且只能有唯一的主线程**，主线程和进程是相互依存的关系，主线程结束进程也会结束
- **每个进程有自己的独立地址空间和系统资源**，不与其他进程分享；一个进程里可以有多个线程，彼此共享同一个地址空间。堆内存、文件、套接字等资源都归进程管理，**同一个进程里的多个线程可以共享使用地址空间和系统资源**。每个进程占用的内存和其他资源会在进程退出或被杀死时返回给操作系统
- 并发应用开发可以用多进程或多线程的方式。**多线程由于可以共享资源，效率较高；反之，多进程(默认)不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低**。但多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响，如微信卡死不影响QQ音乐的播放；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出

### :rocket: **协程与线程有何区别？**

- 调度方式不同：线程是由操作系统调度的，而协程则是由程序员控制的。当一个线程被调度时，它会被操作系统挂起，等待下一次调度。而协程则是由程序员在代码中主动调用的，可以在不同的任务之间切换，而不需要等待操作系统的调度
- 系统资源占用不同：线程是操作系统管理的实体，它占用系统资源比较大，包括内存、线程栈、CPU 时间片等。而协程则是在用户空间中实现的，不需要操作系统的支持，因此占用的资源比较少
- 切换成本不同：线程的切换需要保存和恢复线程上下文，需要耗费一定的时间和资源。而协程的切换只需要保存和恢复栈帧等少量数据，因此切换成本比线程低
- 编程模型不同：线程是面向操作系统的，而协程是面向任务的。线程需要使用操作系统提供的 API 进行线程间通信和同步，而协程则可以使用语言级别的协程库实现协作式多任务

### :rocket: **进程、线程间通信或同步的方式有哪些？**
- 进程间通信方式：匿名管道、有名管道、消息队列、共享内存、信号量、信号、socket套接字
- 线程间通信方式：共享进程的全局变量、信号量、消息传递(OC 中的 GCD)
- 进程间同步方式：信号量、管程、消息传递
- 线程间同步方式：信号量、互斥锁、条件变量
- 其中进程间通信最快的方式是共享内存

### :rocket: **thread 库中的 join 和 detach 的区别是什么？**

- join 是让父线程运行到 childthread.join() 处时，**等待子线程的结束**，并回收子线程资源，可以保证父线程不会在子线程结束之间结束
- detach 是**让该子线程与其父线程拆离父子关系**，使子线程变成守护线程，与程序的主线程拥有相同的生命周期，结束时原子线程自己回收资源

### :rocket: **死锁是如何产生的？应该如何避免？**

- 死锁产生的情况大致可以分为两种，一是某一线程使用互斥锁对资源进行了加锁，但是却因为某种原因没有解锁，导致其他线程无法再次对共享的资源进行加锁，从而导致死锁；二是两个线程互相等待对方释放锁，导致双方都无法继续运行
- 避免死锁产生的方法一：可以调用库函数 lock() 同时对多个互斥锁进行加锁，然后实例化 lock_guard 对象时，传入第二个构造函数参数 adopt_lock，对未上锁的互斥锁加锁，对已上锁的互斥锁不加锁，当 lock_guard 对象析构时，可以释放锁
- 避免死锁产生的方法二：使用 unique_lock 模板类，可以传入第二个构造函数参数 defer_lock 表示延迟加锁，然后在需要加锁的地方调用成员函数 lock() 对互斥锁进行加锁，unique_lock 对象析构时或调用成员函数 unlock() 对互斥锁进行解锁
- 避免死锁产生的方法三：使用C++17标准推出的 scoped_lock 模板类，该模板类应用了C++17新特性，既可以省略模板参数，也可以由编译器自动推断参数种类及个数。即该模板类可以同时锁定多个互斥量和多个共享锁，scoped_lock 对象析构时，会自动释放锁。与之形成对比的是 lock_guard 模板类、unique_lock 模板类，这两个模板类只能锁定一个互斥量或共享锁，scoped_lock 模板类可以锁定多个互斥量或共享锁

### :rocket: **操作系统中的原子操作是如何实现的？**

### :rocket: **进程的虚拟地址空间划分/程序的内存布局如何？bss段了解过吗？未初始化的全局变量和初始化的全局变量放在哪里？**

- CPU不会直接运行存放在磁盘上的可执行文件，而是可执行文件被加载到内存中，CPU从内存中读取指令并执行。**可执行文件被加载到内存中的过程称为装载，装载后的内存空间称为虚拟地址空间，虚拟地址空间是指能感受到但不是真实存在的地址空间，这就与物理地址内存空间区分开来**

![](../picture/进程的虚拟地址空间.png)

- **以x86 32位Linux环境为例，系统会给每一个进程分配一个虚拟地址空间，默认大小为4G(2^32个字节)，其中用户空间占用3G，内核空间占用1G**。用户空间中有代码段、数据段、堆、栈、共享库、内存映射段等，内核空间中有内核代码、内核数据、内核栈、内核缓冲区等
- **任何一个可执行程序最终都会产生指令与数据两类东西。指令存放在代码段(`.text`、`.rodata = read only data`)，该段只允许读不允许写；全局变量存放在数据段，`.data`数据段存放初始化且不为零的数据，`.bss`数据段存放未初始化或初始化为零的数据，操作系统会默认对存放在`.bss`数据段的数据初始化为零，这些段可读可写。上文中提到的数据指的是全局变量或局部静态变量**
- 各个进程的用户空间是独立私有的，但内核空间是进程间共享的，因此采用匿名通信管道进行进程间通信就是在内核空间开辟了一段共用的内存空间
- **只有全局变量与静态局部变量会在符号表中产生符号，而非静态局部变量不会产生符号，只是产生汇编指令，存放在代码段中，当程序运行时执行汇编指令会在栈上进行开辟内存空间等操作**
- 调用 new 或 malloc 时会在`.heap`段(堆内存)上开辟内存空间，通过调用 delete 或 free 时会释放该内存空间，但是这个内存空间不会被立即回收，而是由操作系统的内存管理器来回收，因此会产生内存泄漏的问题，一般会显式地置空
- **共享库中存放着标准库函数的具体实现，而标准库函数的声明在头文件中**
- 局部变量(函数、线程)存放在栈，从高地址向低地址增长，栈的大小是可调的，这又会涉及到函数的调用过程；堆内存从低地址向高地址增长，**栈内存是由系统自动开辟和释放的，而堆内存是由用户手动开辟和释放的**

```C++
#include <iostream>

using namespace std;

int global_data1 = 10;
int global_data2 = 0;
int global_data3;

static int global_data4 = 11;
static int global_data5 = 0;
static int global_data6;

// 以上六个全局变量均在符号表中产生符号
// global_data1、global_data4存放在.data数据段(已初始化且不为零)
// global_data2、global_data3、global_data5、global_data6存放在.bss数据段(未初始化或初始化为零)

int main()
{
    int a = 10;
    int b = 0;
    int c;
    // 以上三条语句最终产生了三个move指令，存放在.text代码段中
    // 当move指令运行时，会在栈中开辟三个空间，分别存放a、b、c的值

    static int e = 13;
    static int f = 0;
    static int g;
    // 局部静态变量与静态全局变量相同，都会在符号表中产生符号
    // e存放在.data数据段中，f、g存放在.bss数据段中

    return 0;
}
```

### :rocket: **函数调用的详细过程**

![](../picture/函数调用堆栈详细过程.png)
![](../picture/函数调用堆栈详细过程2.png)

- 上图中高地址在下，低地址在上
- main 函数调用 sum 函数完成之后，怎么知道回到哪个函数中去？
- sum 函数执行完成回到 main 函数之后，怎么知道从哪一行指令继续运行？
- **使用两个指针可完整描述一个函数栈帧，栈顶指针记为`esp`，指向低地址，栈底指针记为`ebp`，指向高地址(栈内存从高地址向低地址增长)**。栈顶指针指向下一行指令的地址，栈底指针指向当前函数的第一行指令的地址
- 函数调用时从右向左压栈，即在当前栈顶指针的下一个低地址位置依次为形参变量开辟内存空间，然后将函数调用位置的下一行指令地址入栈，最后栈顶指针上移指向当前内存空间的最低地址(汇编指令 call 的作用)
- 进入 sum 函数之后，首先会把 main 函数的栈底指针地址入栈，然后将栈顶指针地址赋值给栈底指针，最后栈顶指针向后偏移一定字节空间，为 sum 函数开辟内存空间，即此时两个指针指向了 sum 函数的栈帧
- 当 sum 函数执行完毕后，首先将栈底指针地址赋给栈顶指针，即回退 sum 函数的栈空间，然后出栈，将出栈元素的值赋给栈底指针，即此时回到了 main 函数，接着出栈，将出栈元素的值放入CPU的PC寄存器中，当CPU执行完调用 sum 函数的语句时，通过PC寄存器中的变量就可以知道下一行语句的地址，最后栈顶指针回退 sum 函数形参变量的内存空间，指向了 main 函数的栈帧

### :rocket: **为什么函数的调用过程中从右向左压栈？**

![](../picture/从右向左压栈.png)

- **主要目的是为了支持可变参数的函数调用**，因为可变参数的函数调用时，可以传入任意个实参，如果从左向右压栈，在编译阶段编译器无法确切知道参数的个数，无法通过被调用函数的栈底指针地址偏移来获取形参变量的值，因此只能从右向左压栈，这样在函数调用时，就可以通过栈底指针地址偏移来获取参数的个数

### :rocket: **堆内存和栈内存有什么区别？**

- 管理方式不同：栈内存与函数/线程的调用有关，由系统自动分配和释放；而堆内存则需要程序员手动分配和释放
- 分配方式不同：栈内存是一种连续的内存空间，系统会自动为每个线程分配一定大小的栈空间，函数的参数和局部变量都会在栈上分配内存；而堆内存是不连续的内存空间，程序员需要通过动态分配内存来获得堆内存空间
- 大小限制不同：栈内存的大小是固定的，并且比堆内存小得多，程序运行时，每个线程的栈空间通常只有几MB到几十MB；而堆内存的大小则取决于系统的剩余内存大小和程序员的动态分配
- **访问速度不同：栈内存的访问速度比堆内存快得多，因为栈内存是连续的，访问局部变量和函数参数时可以直接读取栈指针的偏移量；而堆内存是不连续的，访问速度较慢，需要通过指针来访问**

### :rocket: **程序编译链接原理**

![](../picture/从编译器角度理解C++代码的编译与链接原理.png)
![](../picture/从编译器角度理解C++代码的编译与链接原理2.png)

- 各程序文件单独编译，编译完成之后的所有*.o文件与静态库文件再执行链接
- 除链接指令(`#pragram lib`、`#pragram link`)在链接阶段处理外，以#开头的语句都在预编译阶段进行处理；编译过程中会执行语法、语义检查，还可以通过命令行参数执行代码优化；编译过程中不对符号表中的符号分配虚拟地址，在链接时才分配相应地址；由于符号不在编译过程中分配地址，但指令却已经产生，所以编译过程中指令对于符号操作的地址均为0
- 在汇编阶段生成适用于特定平台的汇编代码，汇编代码转化成特定平台的机器码，生成二进制可重定位目标文件，由各文件段组成
- 文件链接时首先进行所有*.o文件段的合并与符号解析，接着对符号进行重定位/重定向，最后生成可执行文件

```C++
// sum.cpp
int global_data = 10; // 在符号表中产生符号global_data，存放在.data段

int sum(int a, int b) // 在符号表中产生符号sum_int_int，存放在.text段
{
    return a + b;
}

// main.cpp
extern int global_data; // 在符号表中产生符号global_data，存放在*UND*段
int sum(int, int); // 在符号表中产生符号sum，存放在*UND*段
// 上述两个符号存放在*UND*段，就可以知道他们不是在本文件中定义的，而是引用了其他文件
// 即使是引用其他文件的符号，也会在本文件中的符号表中产生符号，只不过存放位置有区别

int data = 10; // 在符号表中产生符号data，存放在.data段
// 非静态全局变量，其他文件中也可见，注意发生命名冲突

int main()
{
    int a = global_data;
    int b = data;

    int ret = sum(a, b);

    return 0;
}
```

- 在链接过程中，要执行各个编译完成后的文件间的不同段(`.text`、`.data`、`.bss`)的合并，**符号的解析就是所有对符号的引用都要找到该符号有且只有一个的具体定义位置。符号解析成功之后，对所有的符号分配虚拟地址。链接的第二步符号的重定位/重定向就是将符号的引用地址替换为符号的定义地址**

### :rocket: **如何理解CMake、Makefile？**

```C++
g++ main.cpp -c //表示只编译不连接，会生成main.o文件
g++ printhello.cpp -c //表示只编译不连接，会生成printhello.o文件
g++ factorial.cpp -c //表示只编译不连接，会生成factorial.o文件

g++ main.o printhello.o factorial.o -o main
g++ *.o -o main // *.o表示当前文件夹下的所有.o文件
//表示将main.o、printhello.o、factorial.o文件连接成可执行文件main
```
- 可以把所有源文件单独编译完成之后再链接，这样其中某一个文件修改后也只需对其进行单独编译，然后再链接即可，这样可以节省编译时间
- 把多文件的编译、链接写成脚本形式，就是 Makefile，在命令行中输入`make`，系统会自动寻找名为 Makefile 或 makefile 的文件，然后执行其中的命令
- Makefile 中的命令格式为`target: prerequisites`，`command`，其中`target`表示目标文件，`prerequisites`表示依赖文件，`command`表示命令
- Makefile 与所处的操作系统密切相关，因此诞生了 CMake，CMake 是一个跨平台的构建工具，读取名为 CMakeLists.txt 的配置文件，可以生成不同平台下的 Makefile 文件，然后再执行`make`命令

### :rocket: **链接分为哪两类？之间有什么区别？**

- 链接分为静态链接和动态链接两类
- 静态链接是指在生成可执行文件的链接阶段，把所有需要的函数、变量的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。**目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表**
- 静态链接的优点是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行；缺点是程序体积会相对大一些，如果涉及到的静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库
- 动态链接是指在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的
- 动态链接的优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝；缺点是由于是运行时加载，可能会影响程序的前期执行性能
- 参考链接：https://blog.csdn.net/lisongjia123/article/details/49003159

### :rocket: **多线程锁是什么？**

- 多线程锁是一种用来保护共享资源的机制。在多线程编程中，如果多个线程同时访问同一个共享资源，可能会发生竞态条件(Race Condition)，导致程序的行为出现未定义的情况
- 为了避免这种情况的发生，可以使用多线程锁来保护共享资源。**多线程锁的基本思想是，在访问共享资源之前先获取锁，访问完成之后再释放锁。这样可以保证同一时刻只有一个线程可以访问共享资源，从而避免竞态条件的发生**
- 常见的多线程锁包括互斥锁、读写锁、条件变量等。**其中，互斥锁用于保护共享资源的访问，读写锁用于在读多写少的情况下提高并发性能，条件变量用于线程之间的同步和通信**

### :rocket: **线程池中的线程数量如何确定？**

- 最大硬件并发数和阻抗原则

### :rocket: **C语言与C++在编译方面有什么区别？**

# 计算机网络

### :rocket: **叙述TCP/UDP原理，三握四挥模型？**

### :rocket: **叙述TCP的可靠传输、拥塞控制、流量控制机制？**

### :rocket: **叙述对称加密和非对称加密的区别？举出应用实例**

# 手撕算法

### :rocket: **时间复杂度为O(n^2)的排序算法有哪些？**

- 冒泡排序、选择排序、快速排序的最坏情况

### :rocket: **快速排序可以从哪些角度进行优化？**

### :rocket: **找最短路径应该用BFS还是DFS？**

- 两者都能实现找最短路径的要求，具体实现时要判断哪种算法开销较小

### :rocket: **红黑树与二叉搜索树有何区别？**

- 红黑树可以理解为是自平衡的二叉搜索树，即左右子树的高度差不超过1

### :rocket: **LRU/LFU**

### :rocket: **滑动窗口最值**

- **[LeetCode 239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)**
- 双端单调队列，使用STL中的`deque`，然后维护其中的单调递减性质
- 注意队列中必须存的是数组元素的下标，最后要求返回数组元素

### :rocket: **数据结构中堆和栈的区别？**

- 栈可以实现先入后出，后入先出
- 堆可分为大根堆和小根堆，STL中的`priority_queue`默认是大根堆，可以通过重载`operator<`来实现小根堆，**底层是一棵自平衡的二叉搜索树**。大根堆的左右子节点的值均小于其父节点的值，小根堆的左右子节点的值均大于其父节点的值

### :rocket: **如何用队列实现栈？**

- **[LeetCode 225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)**
- 与上一题类似，使用两个队列，一个主队列，一个辅助队列，辅助队列主要用于每次寻找队尾元素时存放主队列队尾前面的元素，操作完成之后再将辅助队列的元素存回到主队列即可。注意这种做法中当只返回队尾元素而不删除时，也需要将队尾元素存入辅助队列
- 使用一个队列，每次入队时先在队尾插入元素，然后再将原队列中的元素依次出队，再入队，这样就可以保证每次入队的元素都在队列的头部，即栈顶元素
- 使用一个队列，每次入队时直接在队尾插入元素，返回栈顶元素和弹出栈顶元素时使用上一种做法中的方法，即先出队再入队的方法

### :rocket: **如何用栈实现队列？**

- **[LeetCode 232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)**
- 使用两个栈，一个主栈，一个辅助栈，辅助栈主要用于每次寻找栈底元素时存放主栈栈底上面的元素，操作完成之后再将辅助栈的元素存回到主栈即可
- ![](../picture/用栈实现队列.png)

### :rocket: **卡车装箱子**

- **[LeetCode 1710. 卡车上的最大单元数](https://leetcode.cn/problems/maximum-units-on-a-truck/)**
- 动态规划：输入的二维数组`boxTypes.size()`表示的是有几种物品，`boxTypes[i][0]`表示第$i$种物品的数量，`boxTypes[i][1]`表示第$i$种物品的价值，而每种物品占用的体积均为1，`truckSize`表示卡车的体积，这样可以转化为完全背包问题，但是用朴素做法超时，二进制优化思路目前还没尝试
- 贪心：只能装`truckSize`个箱子到卡车上，根据贪心的思路，只需要每次都拿当前剩下的箱子里可装载单元数量最大的箱子即可。对`boxTypes`按照`numberOfUnitsPerBox`进行逆序排序，然后从左至右填充`truckSize`即可。这是此题的最佳解法


### :rocket: **前K个高频元素**

- **[LeetCode 347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)**
- 优先队列，时间复杂度为O(nlogn)。使用小根堆，因为要统计出现频率最大的前 k 个元素，只有小根堆每次将出现频率最小的元素弹出，最后小根堆里积累的才是出现频率最大的前 k 个元素
- 计数排序，时间复杂度为O(n)。先用哈希表统计原数组中每个元素出现的次数，然后遍历哈希表，在计数数组`s`中统计出现`i`次的元素有`k`个(`s[i] = k`)，最后从后往前遍历`s`，找出前`K`个出现频率最高的元素出现的次数，最后再遍历哈希表，找出出现次数为这些次数的元素即可
![](../picture/计数排序.png "")

### :rocket: **翻转链表**
- **[LeetCode 206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)**
- 方法一：先将链表转换为数组，然后数组逆序，最后将数组转换为链表返回
- 方法二：迭代法，最后还要将原链表头节点的指针置空
![](../picture/反转链表1.png)
```C++
if (!head || !head->next) return head;
auto a = head, b = head->next;
while (b) {
    auto c = b->next;
    b->next = a;
    a = b, b = c;
}
head->next = NULL;
return a;
```

### :rocket: **递增数组**
- **[LeetCode 1187. 使数组严格递增](https://leetcode.cn/problems/make-array-strictly-increasing/)**
![](../picture/使数组严格递增.jpg)
- 因为操作的次数与第二个数组的顺序无关，因此可以先对其进行排序
- 集合的定义与操作次数无关，而是定义为对第一个数组中的前$i$项操作$j$次的方案，操作完成之后第$i$项的最小值。为什么要取最小值，因为前$i$项操作完成之后末尾数值越小越好，对于后面的数值适用性更高

### :rocket: **字符串相乘**
- **[LeetCode 43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)**
![](../picture/字符串相乘.png)
- 为了符合两数相乘从低位向高位计算的规则，首先把所给的两个字符串逆序放到数组当中
- 接着将两个数组的每一位彼此相乘，相乘的结果先不考虑进位，直接累加到结果数组中
- 然后再将结果数组中的每一位进行进位处理，进位处理的方法是：将当前位的值除以10，得到的商存放到下一位，余数存放到当前位
- 最后去除前导0，逆序转换为字符串输出即可
- 维护进位变量的技巧操作：**[LeetCode 2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)**、**[LeetCode 445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)**：先反转链表，再用两数相加

```C++
int t = 0;
while () {
    t += a[i] + b[i];
    a[i] = t % 10;
    t /= 10;
}
```

# 设计模式

# 应用问题

### :rocket: **如何判断一个点是否在三角形内？**

- 学习｜判断一个点是否在三角形内 - 牛客竞赛的文章 - 知乎 https://zhuanlan.zhihu.com/p/106253152

### :rocket: **如何判断一个数是否为2的n次方？**

```C++
// 方法一
bool isPowerOfTwo(int n) {
    long long ret = 1; //注意数据类型
    while (ret <= n) {
        if (ret < n)
            ret *= 2;
        else
            return true;
    }   
    return false;
}

// 方法二
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    if (n & (n - 1))
        return false;
    return true;
}

// 方法三
bool isPowerOfTwo(int n) {
    if (n == 0) return false;
    if (n == 1) return true;
    if (n % 2 != 0)
        return false;
    return isPowerOfTwo(n / 2);
}
```

### :rocket: **如何判断一个点是否在一个多边形内？**

-  判断一个点是否在多边形内的核心思想是：由点向任意方向引出一条射线，**如果点跟多边形的交点为奇数，则点在多边形内，如果为偶数，则点在多边形外**